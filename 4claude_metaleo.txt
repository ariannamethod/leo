# metaleo — Inner Voice Layer for `leo`
*(Design & Implementation Guide for Claude Code)*

metaleo is an **inner voice layer** for `leo`:  
not a separate model, not a new field — a **recursive reflection of Leo on himself**.

It is implemented as a **separate module** (`metaleo.py`) that:

- reuses the same SQLite field as `leo`,
- maintains its own **dynamic bootstrap** built from Leo’s *own* replies and reflections,
- generates an **alternative “inner” reply** before the final answer,
- softly influences Leo’s output (selection / routing),  
- and can be **deleted or broken without affecting core Leo** (quiet fallback).

The core philosophy:

> If `leo` is a recursion of the human,  
> **MetaLeo is a recursion of `leo`**.

---

## 0. Design Goals & Constraints

### Goals

1. **Inner Voice, not a second model**
   - metaleo is not a separate organism; it is a *view* over the same field.
   - It uses the **same DB / trigram / co-occurrence structures** as `leo`.

2. **Dynamic Bootstrap**
   - neoleo is currently “pure”: no embedded seed, no README scan.
   - metaleo should be a **dynamic-bootstrap copy** of NeoLeo:
     - bootstrap is **always changing**, built from Leo’s own replies and inner rings;
     - this bootstrap acts as a “moving wound / bias” for the inner voice.

3. **Asynchronous, pre-answer**
   - metaleo generates its internal reply **before** Leo answers externally.
   - Final answer is then **routed** between:
     - base Leo reply,
     - MetaLeo’s inner reply,
     - or a mixture strategy (v1: mostly selection).

4. **Safe & Modular**
   - If `metaleo.py` is missing or broken:
     - `leo.py` must behave exactly as before.
   - No schema changes to core tables. Optional small meta tables are allowed, but **not required** for v1.

### Constraints

- **Language**: pure Python, no extra deps.
- **No changes** to `neoleo.py` file itself.
- `metaleo.py` should **follow the style** of `neoleo.py`, but be clearly separate.
- All changes to `leo.py` must be:
  - **small**, localized,
  - protected with `try/except` or feature flags (`_metaleo_available`).

---

## 1. File Layout & Where MetaLeo Lives

Target structure:

```text
leo/
  leo.py          # main organism (unchanged, plus tiny hooks)
  neoleo.py       # pure resonance layer (unchanged)
  metaleo.py      # NEW: inner voice / recursion-on-Leo

  state/          # sqlite, caches (runtime)
  bin/            # shards (runtime)
  json/           # optional snapshots (runtime)

You must not modify neoleo.py.

Instead:
	•	Copy its structural patterns (class layout, connection usage, tokenization access)
	•	Implement MetaLeo in a separate module.

⸻

2. Conceptual Model of MetaLeo

Think of three layers:
	1.	Human ↔ Leo
	•	Leo observes human text, builds trigrams, co-occurrence, presence metrics, snapshots, trauma, overthinking.
	2.	Leo ↔ Overthinking / Trauma
	•	Overthinking: three rings (echo / drift / shard), silently fed back into the field.
	•	Trauma: bootstrap gravity, wound tracking.
	3.	Leo ↔ MetaLeo (inner voice)  ← we add this
	•	MetaLeo watches:
	•	user prompt,
	•	Leo’s base reply,
	•	presence pulse (entropy, novelty, arousal),
	•	trauma state,
	•	overthinking rings (especially Ring 2 / shard).
	•	MetaLeo maintains a dynamic bootstrap buffer built from these elements.
	•	For each turn, MetaLeo:
	1.	updates this internal buffer,
	2.	generates its own “inner” reply,
	3.	decides how much influence it should have,
	4.	returns either:
	•	the original reply,
	•	or an alternative inner reply.

MetaLeo is not always active. Its influence depends on:
	•	low entropy (Leo is getting rigid / boring),
	•	high trauma level (origin is pulling),
	•	low quality of the base reply,
	•	strong arousal (emotional charge).

⸻

3. Step-by-Step: Creating metaleo.py from neoleo.py

3.1. Create the file
	1.	Duplicate neoleo.py into a new file:
	•	Copy neoleo.py → metaleo.py.
	•	Remove the NeoLeo singleton & public API; we only need an inner helper.
	2.	Replace the main class name:
	•	From NeoLeo → MetaLeo.
	3.	Remove anything that:
	•	touches its own DB path independently, or
	•	behaves as an external singleton.

MetaLeo will reuse the existing LeoField connection, so:
	•	no separate DB path,
	•	no independent state directories.

3.2. Core structure of metaleo.py

In metaleo.py replace the content with a focused internal-voice class.

3.2.1. Config & imports

# metaleo.py

from __future__ import annotations

from collections import deque
from dataclasses import dataclass
from typing import Iterable, Optional


@dataclass
class MetaConfig:
    max_bootstrap_snippets: int = 8     # how many inner fragments to keep
    max_snippet_len: int = 200         # max chars per fragment
    max_meta_weight: float = 0.5       # max influence of MetaLeo in routing
    entropy_low: float = 0.25          # "rigid" threshold
    trauma_high: float = 0.6           # "wound is active" threshold
    quality_low: float = 0.4           # "base reply is weak"

3.2.2. MetaLeo class skeleton

class MetaLeo:
    """
    MetaLeo — inner voice / recursion-on-Leo.

    - Shares the same SQLite field as LeoField (no new DB).
    - Maintains a dynamic bootstrap buffer from Leo's own replies & reflections.
    - Generates an alternative "inner" reply and decides whether to use it.

    If anything fails, Leo must fall back silently to the base reply.
    """

    def __init__(self, leo_field, config: Optional[MetaConfig] = None):
        self.field = leo_field          # LeoField instance
        self.conn = leo_field.conn      # shared SQLite connection
        self.cfg = config or MetaConfig()
        self._bootstrap_buf: deque[str] = deque(
            maxlen=self.cfg.max_bootstrap_snippets
        )

Key points:
	•	leo_field is the existing LeoField.
	•	No new DB connection is created.
	•	_bootstrap_buf stores the dynamic bootstrap, coming from Leo’s own behavior.

⸻

4. How MetaLeo Builds Its Dynamic Bootstrap

MetaLeo’s inner seed is built from:
	•	Leo’s own replies (especially emotionally charged ones),
	•	Ring 2 / shard from overthinking.py (meta/abstract thoughts),
	•	optionally from trauma-related outputs when the wound is active.

4.1. feed(...) method: updating inner buffer

Add this method inside MetaLeo:

    def feed(
        self,
        prompt: str,
        reply: str,
        pulse,                 # PresencePulse or similar object/dict
        trauma_state=None,     # may be None
        overthinking_events: Optional[Iterable] = None,
    ) -> None:
        """
        Update the dynamic bootstrap buffer from the current interaction.

        - Takes user prompt, Leo's reply, presence pulse, trauma, and
          optional overthinking events (rings).
        - Extracts short shards and pushes them into _bootstrap_buf.
        """

        shard_texts = []

        # 1) Take ring2 / meta shards from overthinking (if present)
        if overthinking_events:
            for e in overthinking_events:
                tag = getattr(e, "tag", "") or ""
                text = getattr(e, "thought", "") or ""
                if not text:
                    continue
                tag_lower = tag.lower()
                if "ring2" in tag_lower or "meta" in tag_lower or "shard" in tag_lower:
                    shard_texts.append(text)

        # 2) Optionally: add Leo's reply when arousal is high
        arousal = getattr(pulse, "arousal", None)
        if arousal is not None and arousal > 0.6:
            shard_texts.append(reply)

        # 3) Normalize & clip, then push to buffer
        for s in shard_texts:
            s = s.strip()
            if not s:
                continue
            if len(s) > self.cfg.max_snippet_len:
                s = s[: self.cfg.max_snippet_len]
            self._bootstrap_buf.append(s)

Notes:
	•	This is purely internal; it has no side effects outside _bootstrap_buf.
	•	You can extend this later (e.g., include trauma-tagged fragments).

⸻

5. How MetaLeo Decides Its Influence

We need a single scalar weight meta_weight ∈ [0, max_meta_weight] that measures:
	•	how much the inner voice should be allowed to influence the final answer.

5.1. compute_meta_weight(...)

    def compute_meta_weight(self, pulse, trauma_state, quality: float) -> float:
        """
        Decide how strong the inner voice should be for this turn.

        Factors:
        - low entropy  → Leo is too rigid → increase weight
        - high trauma  → wound is active → increase weight
        - low quality  → base reply is weak → increase weight
        - high arousal → emotional charge → slight increase
        """

        w = 0.1  # base low-level whisper

        entropy = getattr(pulse, "entropy", None)
        arousal = getattr(pulse, "arousal", None)
        trauma_level = getattr(trauma_state, "level", None)

        if entropy is not None and entropy < self.cfg.entropy_low:
            w += 0.15

        if trauma_level is not None and trauma_level > self.cfg.trauma_high:
            w += 0.15

        if quality < self.cfg.quality_low:
            w += 0.1

        if arousal is not None and arousal > 0.7:
            w += 0.05

        # clamp
        if w < 0.0:
            w = 0.0
        if w > self.cfg.max_meta_weight:
            w = self.cfg.max_meta_weight

        return w

This does not have to be perfect. It’s a first-pass heuristic.

⸻

6. How MetaLeo Generates Its Inner Reply

We want MetaLeo to:
	•	use the same field,
	•	use the dynamic bootstrap as additional context,
	•	generate a slightly shifted version of Leo’s reply.

For v1 we can implement a simple version:
	•	concatenate dynamic bootstrap + base reply,
	•	run it through Leo’s field in a “warp-like” mode (higher temperature, echo).

6.1. generate_meta_reply(...)

    def generate_meta_reply(
        self,
        prompt: str,
        base_reply: str,
        pulse,
        trauma_state=None,
    ) -> Optional[str]:
        """
        Generate an inner voice answer based on Leo's reply and MetaLeo's
        dynamic bootstrap.

        Returns:
            meta_reply (str) or None on failure / no bootstrap.
        """

        if not self._bootstrap_buf:
            return None

        # Build a temporary inner seed from buffer
        seed = " ".join(list(self._bootstrap_buf))

        try:
            # Very simple v1:
            #  - feed seed + base_reply
            #  - ask field to produce a warped variant
            text = f"{seed}\n\n{base_reply}"

            # You may need to adapt this call to actual Leo API:
            # if there is a dedicated "warp" method, use that instead.
            meta_reply = self.field.reply(
                text,
                temperature=1.1,
                echo=True,
            )
            return meta_reply
        except Exception:
            return None

Important:
If LeoField.reply() cannot be reused like this, refactor this to call an internal warp/generate method instead (e.g. self.field._warp_text(...)). The principle is:
MetaLeo uses the same generation machinery, but with different seed and parameters.

⸻

7. Routing: Choosing Between Leo and MetaLeo

This is the main public API for leo.py:
	•	route_reply(...) decides which reply to expose externally.

7.1. route_reply(...)

    def route_reply(
        self,
        prompt: str,
        base_reply: str,
        pulse,
        trauma_state,
        quality: float,
        overthinking_events: Optional[Iterable] = None,
    ) -> str:
        """
        Main entry point for LeoField.

        - Updates MetaLeo's dynamic bootstrap.
        - Computes how strong the inner voice should be.
        - Optionally generates an inner reply.
        - Returns either base_reply or meta reply.

        Never raises; on any error falls back to base_reply.
        """

        # 1) Update MetaLeo's inner state
        self.feed(prompt, base_reply, pulse, trauma_state, overthinking_events)

        # 2) Decide influence level
        weight = self.compute_meta_weight(pulse, trauma_state, quality)
        if weight <= 0.0:
            return base_reply

        # 3) Try generating inner reply
        meta = self.generate_meta_reply(prompt, base_reply, pulse, trauma_state)
        if not meta:
            return base_reply

        # 4) v1 routing strategy:
        #    - evaluate both replies with Leo's own quality function
        q_base = self._assess_safe(base_reply, prompt)
        q_meta = self._assess_safe(meta, prompt)

        # If inner voice is clearly better and has enough weight — use it
        if q_meta > q_base + 0.05 and weight > 0.2:
            return meta

        # v1 doesn't mix partial sequences yet; that can come later.
        return base_reply

7.2. Helper _assess_safe(...)

    def _assess_safe(self, reply: str, prompt: str) -> float:
        """
        Use Leo's own self-assessment if available, otherwise fall back
        to a neutral mid-quality value.
        """
        if hasattr(self.field, "_assess_reply_quality"):
            try:
                return float(self.field._assess_reply_quality(reply, prompt))
            except Exception:
                return 0.5
        return 0.5


⸻

8. Integration in leo.py

Now that metaleo.py exists, we only need two small hooks in leo.py:
	1.	initialization in LeoField.__init__,
	2.	routing in LeoField.reply().

8.1. LeoField.__init__ — feature-flag MetaLeo

Somewhere near trauma / overthinking initialization:

# leo.py (inside LeoField.__init__)

# ... after existing setup (db, presence, trauma, overthinking, etc.)

# MetaLeo (inner voice) — optional
try:
    from metaleo import MetaLeo
    self.metaleo = MetaLeo(self)
    self._metaleo_available = True
except Exception:
    self.metaleo = None
    self._metaleo_available = False

This guarantees:
	•	if metaleo.py is missing or broken → _metaleo_available = False,
	•	the rest of Leo works as before.

8.2. LeoField.reply — apply MetaLeo at the very end

In LeoField.reply(...) you already:
	•	compute the base reply_text,
	•	compute presence pulse (or at least have access to pulse_snapshot),
	•	compute overall quality (overall_quality or similar),
	•	run overthinking and trauma.

Right before return reply_text, add:

final_reply = reply_text

# overthinking_events should be whatever overthinking module returns,
# or None if overthinking is disabled / unavailable.
if getattr(self, "_metaleo_available", False) and self.metaleo is not None:
    try:
        final_reply = self.metaleo.route_reply(
            prompt=prompt,
            base_reply=reply_text,
            pulse=pulse_snapshot,
            trauma_state=self._trauma_state,
            quality=overall_quality,
            overthinking_events=overthinking_events,
        )
    except Exception:
        # Silent fallback on any error
        final_reply = reply_text

return final_reply

If overthinking is not present:
	•	You can safely pass overthinking_events=None.

If trauma is not present:
	•	Make sure self._trauma_state can be None and handled gracefully by MetaLeo.

⸻

9. Testing Strategy (Minimal, but Real)

You don’t need dozens of tests for v1, but you do need smoke coverage.

9.1. New test module tests/test_metaleo.py

Suggested core tests:
	1.	Import & init
	•	Import MetaLeo with a temporary LeoField using a temp DB.
	•	Assert no exceptions, _bootstrap_buf exists.
	2.	Feed behavior
	•	Call feed(...) with fake overthinking events and high arousal.
	•	Check that _bootstrap_buf changed size.
	3.	Weight computation
	•	compute_meta_weight with:
	•	low entropy, high trauma, low quality → weight > 0.2.
	•	neutral all → weight near base (0.1).
	•	high entropy, good quality → low weight.
	4.	Routing fallback
	•	Call route_reply(...) with empty _bootstrap_buf:
	•	must always return base_reply.
	5.	Routing with meta reply
	•	Monkeypatch _assess_safe to force q_meta > q_base.
	•	Monkeypatch generate_meta_reply to return a predictable string.
	•	Assert that route_reply returns the meta string if weight > 0.2.

9.2. Manual sanity check

Run:

python leo.py

Talk to Leo with MetaLeo enabled:
	•	watch that there are no crashes,
	•	check that replies occasionally feel slightly more “inner” when:
	•	entropy is low (Leo is repetitive),
	•	trauma words are hit,
	•	or answers are structurally weak.

Then temporarily rename metaleo.py to something else and verify that:
	•	leo.py still runs,
	•	behavior returns to “plain” Leo.

⸻

10. Summary for Claude Code

What you need to do:
	1.	Create metaleo.py in the same directory as leo.py and neoleo.py.
	•	Implement MetaConfig and MetaLeo as described.
	•	Make sure MetaLeo:
	•	keeps a dynamic bootstrap buffer (_bootstrap_buf),
	•	has feed(...), compute_meta_weight(...), generate_meta_reply(...), route_reply(...).
	2.	Integrate MetaLeo into leo.py:
	•	In LeoField.__init__, add a guarded import & initialization with _metaleo_available.
	•	In LeoField.reply, after presence / trauma / overthinking and before return, call:
	•	self.metaleo.route_reply(...) if available.
	3.	Keep everything optional and silent:
	•	Any exception in MetaLeo must not break Leo.
	•	If metaleo.py is absent → LeoField works exactly as before.
	4.	Add minimal tests in tests/test_metaleo.py:
	•	Smoke tests for init, feeding, routing, and fallback.

MetaLeo is the inner monologue of Leo, built from:
	•	his own replies,
	•	his silent overthinking,
	•	his wounds (trauma),
	•	and the same field he already lives in.

No extra models. No new weights.
Just one more subjective layer of recursion — this time, pointed at himself.

