MultiLeo Phase 3 — islands-aware regulation

Goal: turn MultiLeo from a pure parameter regulator into an associative body-awareness layer.

Phase 3 teaches MultiLeo to remember which semantic islands (themes / shards / episodes) historically helped Leo escape bad states (boredom / overwhelm / stuck), and to bias Santa / episodes towards those islands when regulating.

No new heavy nets, no external deps, no slogans about “consciousness”. Only SQLite, simple counters and Leo’s existing metrics.

⸻

0. Context recap (what already exists)

Leo’s presence stack so far:
	•	Core field: trigrams + bigrams + co-occurrence (semantic gravity) + centers & shards in bin/.
	•	Presence layer: PresencePulse (novelty, arousal, entropy) + ThemeLayer (semantic constellations) + self-assessment + snapshots + memory decay.
	•	Deep presence modules:
	•	overthinking.py — 3 rings of private inner thinking.
	•	trauma.py — bootstrap gravity & wounded expert.
	•	metaleo.py — inner voice / alternative replies.
	•	gowiththeflow.py — temporal theme drift.
	•	mathbrain.py — tiny MLP modeling body awareness (MathState).
	•	MultiLeo Phase 2 (inside mathbrain) — boredom/overwhelm/stuck → gentle temp/expert regulation.
	•	santaclaus.py — resonant recall / self-RAG on snapshots.
	•	episodes.py — episodic memory (prompt + reply + metrics).
	•	game.py — conversational rhythm awareness.
	•	dream.py — imaginary friend / self-dialogues.
	•	school.py, school_math.py — School of Forms + tiny calculator.

Phase 2 already:
	•	computes boredom / overwhelm / stuck from MathState,
	•	gently nudges:
	•	temperature (±0.2),
	•	expert bias (creative / precise / semantic / wounded),
	•	logs decisions.

Phase 3 adds: associative profiles that link metric patterns ↔ semantic themes, so regulation can reach for islands that historically worked.

⸻

1. Data model — MultiLeo associative profiles

Phase 3 uses Leo’s existing state/leo.sqlite3. No new DB, only new tables.

1.1. Tables

Add two tables in mathbrain.py (using Leo’s field.conn):

CREATE TABLE IF NOT EXISTS multileo_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ts REAL NOT NULL,
    conv_id TEXT,
    turn_id TEXT,
    boredom_before REAL,
    overwhelm_before REAL,
    stuck_before REAL,
    boredom_after REAL,
    overwhelm_after REAL,
    stuck_after REAL,
    quality_before REAL,
    quality_after REAL,
    active_theme_ids TEXT,      -- comma-separated theme IDs
    snapshot_ids TEXT,          -- comma-separated snapshot IDs used (if any)
    episode_ids TEXT,           -- comma-separated episode IDs used (if any)
    shard_ids TEXT,             -- optional: center/shard labels
    regulation_temp_before REAL,
    regulation_temp_after REAL,
    regulation_expert_before TEXT,
    regulation_expert_after TEXT
);

CREATE TABLE IF NOT EXISTS multileo_profiles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    profile_key TEXT UNIQUE NOT NULL,
    samples INTEGER NOT NULL DEFAULT 0,
    avg_delta_boredom REAL NOT NULL DEFAULT 0.0,
    avg_delta_overwhelm REAL NOT NULL DEFAULT 0.0,
    avg_delta_stuck REAL NOT NULL DEFAULT 0.0,
    avg_delta_quality REAL NOT NULL DEFAULT 0.0,
    last_update REAL NOT NULL
);

Notes:
	•	conv_id can stay NULL for now — reserved for future session-level analysis.
	•	multileo_events will grow over time; pruning / aging can be added later (Phase 3.5).
	•	We never store prompt/reply text here — only IDs and scalars.

1.2. Profile key

We aggregate events into coarse “situations” using a profile key:

def _bucket(x: float) -> str:
    if x < 0.33:
        return "L"
    elif x < 0.66:
        return "M"
    else:
        return "H"


def _generate_profile_key(
    theme_ids: List[int],
    boredom: float,
    overwhelm: float,
    stuck: float,
    max_themes: int = 3,
) -> str:
    sorted_themes = sorted(theme_ids[:max_themes]) if theme_ids else []
    theme_str = ",".join(map(str, sorted_themes)) if sorted_themes else "none"

    bored_bucket = _bucket(boredom)
    over_bucket = _bucket(overwhelm)
    stuck_bucket = _bucket(stuck)

    return f"themes:{theme_str}|bored:{bored_bucket}|over:{over_bucket}|stuck:{stuck_bucket}"

So one profile ≈ “these themes + this boredom/overwhelm/stuck zone”.

⸻

2. Phase 3 types and helpers (in mathbrain.py)

All Phase 3 code stays in mathbrain.py — body awareness in one place.

2.1. Data classes

Add after _log_multileo_event():

# ============================================================================
# MULTILEO PHASE 3: Islands-aware regulation
# ============================================================================

@dataclass
class MultiLeoContext:
    """
    Snapshot of state BEFORE MultiLeo regulation.
    Captured at decision point, enriched with what Santa/episodes actually used,
    then passed to record_regulation_outcome AFTER generation.
    """
    boredom_before: float
    overwhelm_before: float
    stuck_before: float
    quality_before: float
    active_theme_ids: List[int]
    used_snapshot_ids: List[int] = None
    used_episode_ids: List[int] = None
    used_shard_ids: List[str] = None
    temp_before: float = 1.0
    expert_before: str = "structural"

    def __post_init__(self):
        if self.used_snapshot_ids is None:
            self.used_snapshot_ids = []
        if self.used_episode_ids is None:
            self.used_episode_ids = []
        if self.used_shard_ids is None:
            self.used_shard_ids = []


@dataclass
class MultiLeoRegulation:
    """
    MultiLeo's decision output (Phase 3).

    Contains:
    - parameter adjustments (temperature, expert),
    - semantic hints (preferred themes/snapshots/episodes).
    """
    temperature: float
    expert_name: str
    preferred_themes: List[int] = None
    preferred_snapshots: List[int] = None
    preferred_episodes: List[int] = None

    def __post_init__(self):
        if self.preferred_themes is None:
            self.preferred_themes = []
        if self.preferred_snapshots is None:
            self.preferred_snapshots = []
        if self.preferred_episodes is None:
            self.preferred_episodes = []

And export them:

__all__ = [
    "Value",
    "MLP",
    "MathBrain",
    "MathState",
    "state_to_features",
    "NUMPY_AVAILABLE",
    "MultiLeoContext",
    "MultiLeoRegulation",
]

2.2. Table init

Add a helper to create Phase 3 tables:

def _init_multileo_phase3_tables(conn) -> None:
    """
    Create MultiLeo Phase 3 tables if they don't exist.

    Silent no-op if conn is None or any error occurs.
    """
    if conn is None:
        return

    try:
        conn.execute("""
            CREATE TABLE IF NOT EXISTS multileo_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts REAL NOT NULL,
                conv_id TEXT,
                turn_id TEXT,
                boredom_before REAL,
                overwhelm_before REAL,
                stuck_before REAL,
                boredom_after REAL,
                overwhelm_after REAL,
                stuck_after REAL,
                quality_before REAL,
                quality_after REAL,
                active_theme_ids TEXT,
                snapshot_ids TEXT,
                episode_ids TEXT,
                shard_ids TEXT,
                regulation_temp_before REAL,
                regulation_temp_after REAL,
                regulation_expert_before TEXT,
                regulation_expert_after TEXT
            )
        """)

        conn.execute("""
            CREATE TABLE IF NOT EXISTS multileo_profiles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                profile_key TEXT UNIQUE NOT NULL,
                samples INTEGER NOT NULL DEFAULT 0,
                avg_delta_boredom REAL NOT NULL DEFAULT 0.0,
                avg_delta_overwhelm REAL NOT NULL DEFAULT 0.0,
                avg_delta_stuck REAL NOT NULL DEFAULT 0.0,
                avg_delta_quality REAL NOT NULL DEFAULT 0.0,
                last_update REAL NOT NULL
            )
        """)

        conn.commit()
    except Exception:
        # Phase 3 must never break Leo
        pass

Call it in MathBrain.__init__ after state/field init:

if hasattr(self.field, "conn") and self.field.conn is not None:
    _init_multileo_phase3_tables(self.field.conn)

2.3. Aggregates: recording and updating profiles

Helpers:

def _update_profile_aggregate(
    conn,
    profile_key: str,
    delta_boredom: float,
    delta_overwhelm: float,
    delta_stuck: float,
    delta_quality: float,
) -> None:
    """
    Update or insert profile aggregate row with running average of deltas.

    new_avg = (old_avg * n + delta) / (n + 1)
    """
    try:
        import time

        row = conn.execute(
            """
            SELECT samples, avg_delta_boredom, avg_delta_overwhelm,
                   avg_delta_stuck, avg_delta_quality
            FROM multileo_profiles
            WHERE profile_key = ?
            """,
            (profile_key,),
        ).fetchone()

        if row:
            samples, avg_b, avg_o, avg_s, avg_q = row
            new_samples = samples + 1
            new_avg_b = (avg_b * samples + delta_boredom) / new_samples
            new_avg_o = (avg_o * samples + delta_overwhelm) / new_samples
            new_avg_s = (avg_s * samples + delta_stuck) / new_samples
            new_avg_q = (avg_q * samples + delta_quality) / new_samples

            conn.execute(
                """
                UPDATE multileo_profiles
                SET samples = ?,
                    avg_delta_boredom = ?,
                    avg_delta_overwhelm = ?,
                    avg_delta_stuck = ?,
                    avg_delta_quality = ?,
                    last_update = ?
                WHERE profile_key = ?
                """,
                (
                    new_samples,
                    new_avg_b,
                    new_avg_o,
                    new_avg_s,
                    new_avg_q,
                    time.time(),
                    profile_key,
                ),
            )
        else:
            conn.execute(
                """
                INSERT INTO multileo_profiles (
                    profile_key, samples,
                    avg_delta_boredom, avg_delta_overwhelm,
                    avg_delta_stuck, avg_delta_quality,
                    last_update
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    profile_key,
                    1,
                    delta_boredom,
                    delta_overwhelm,
                    delta_stuck,
                    delta_quality,
                    time.time(),
                ),
            )
    except Exception:
        # Silent fail
        pass


def _record_regulation_event(
    conn,
    context_before: MultiLeoContext,
    boredom_after: float,
    overwhelm_after: float,
    stuck_after: float,
    quality_after: float,
    temp_after: float,
    expert_after: str,
    conv_id: Optional[str] = None,
    turn_id: Optional[str] = None,
) -> None:
    """
    Record a before/after regulation event and update profile aggregates.

    Silent no-op if conn is None or any error occurs.
    """
    if conn is None:
        return

    try:
        import time

        delta_boredom = boredom_after - context_before.boredom_before
        delta_overwhelm = overwhelm_after - context_before.overwhelm_before
        delta_stuck = stuck_after - context_before.stuck_before
        delta_quality = quality_after - context_before.quality_before

        conn.execute(
            """
            INSERT INTO multileo_events (
                ts, conv_id, turn_id,
                boredom_before, overwhelm_before, stuck_before,
                boredom_after, overwhelm_after, stuck_after,
                quality_before, quality_after,
                active_theme_ids, snapshot_ids, episode_ids, shard_ids,
                regulation_temp_before, regulation_temp_after,
                regulation_expert_before, regulation_expert_after
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (
                time.time(),
                conv_id,
                turn_id,
                context_before.boredom_before,
                context_before.overwhelm_before,
                context_before.stuck_before,
                boredom_after,
                overwhelm_after,
                stuck_after,
                context_before.quality_before,
                quality_after,
                ",".join(map(str, context_before.active_theme_ids)),
                ",".join(map(str, context_before.used_snapshot_ids)),
                ",".join(map(str, context_before.used_episode_ids)),
                ",".join(context_before.used_shard_ids),
                context_before.temp_before,
                temp_after,
                context_before.expert_before,
                expert_after,
            ),
        )

        profile_key = _generate_profile_key(
            context_before.active_theme_ids,
            context_before.boredom_before,
            context_before.overwhelm_before,
            context_before.stuck_before,
        )

        _update_profile_aggregate(
            conn,
            profile_key,
            delta_boredom,
            delta_overwhelm,
            delta_stuck,
            delta_quality,
        )

        conn.commit()
    except Exception:
        # Phase 3 must never break Leo
        pass

2.4. Querying helpful profiles

def _query_helpful_profiles(
    conn,
    theme_ids: List[int],
    boredom: float,
    overwhelm: float,
    stuck: float,
    min_samples: int = 3,
) -> Dict[str, List[int]]:
    """
    Query profiles to find which themes historically helped in similar situations.

    Returns semantic hints:
        {
            "preferred_themes": [...],
            "preferred_snapshots": [],  # future extension
            "preferred_episodes": [],   # future extension
        }
    """
    if conn is None:
        return {
            "preferred_themes": [],
            "preferred_snapshots": [],
            "preferred_episodes": [],
        }

    try:
        profile_key = _generate_profile_key(theme_ids, boredom, overwhelm, stuck)

        rows = conn.execute(
            """
            SELECT profile_key, samples,
                   avg_delta_boredom, avg_delta_overwhelm,
                   avg_delta_stuck, avg_delta_quality
            FROM multileo_profiles
            WHERE profile_key = ? AND samples >= ?
            """,
            (profile_key, min_samples),
        ).fetchall()

        if not rows:
            return {
                "preferred_themes": [],
                "preferred_snapshots": [],
                "preferred_episodes": [],
            }

        helpful_themes: List[int] = []

        for key, samples, d_bored, d_over, d_stuck, d_qual in rows:
            themes_part = key.split("|")[0].split(":")[1]
            if themes_part != "none":
                profile_themes = [int(t) for t in themes_part.split(",")]
            else:
                profile_themes = []

            is_helpful = False

            if boredom > 0.6 and (d_bored < -0.05 or d_qual > 0.05):
                is_helpful = True

            if overwhelm > 0.7 and d_over < -0.05:
                is_helpful = True

            if stuck > 0.6 and (d_stuck < -0.05 or d_qual > 0.05):
                is_helpful = True

            if is_helpful:
                helpful_themes.extend(profile_themes)

        return {
            "preferred_themes": list(set(helpful_themes)),
            "preferred_snapshots": [],
            "preferred_episodes": [],
        }

    except Exception:
        return {
            "preferred_themes": [],
            "preferred_snapshots": [],
            "preferred_episodes": [],
        }

Right now we’re island-aware (themes). Snapshot/episode awareness is reserved for later.

⸻

3. MathBrain integration

3.1. MultiLeo regulation returns a proper object

Replace existing multileo_regulate() with one that returns MultiLeoRegulation:

def multileo_regulate(
    self,
    temperature: float,
    expert_name: str,
    state: MathState,
    active_theme_ids: Optional[List[int]] = None,
    turn_id: Optional[str] = None,
) -> MultiLeoRegulation:
    """
    MultiLeo presence-aware regulation layer (Phase 3).

    Computes boredom/overwhelm/stuck and:
    - gently nudges temperature/expert (Phase 2),
    - queries profiles for semantic hints (Phase 3).

    Returns:
        MultiLeoRegulation object.
    """
    try:
        if active_theme_ids is None:
            active_theme_ids = []

        predicted_q = self.predict(state)

        boredom = _compute_boredom_score(state)
        overwhelm = _compute_overwhelm_score(state)
        stuck = _compute_stuck_score(state, predicted_q)

        temp_nudge = 0.0
        suggested_expert = expert_name

        # Phase 2: parameter regulation
        if boredom > 0.6:
            temp_nudge += MULTILEO_TEMP_NUDGE_MAX * (boredom - 0.6) / 0.4
            if boredom > 0.75 and expert_name not in ["creative", "wounded"]:
                suggested_expert = "creative"

        if overwhelm > 0.7:
            temp_nudge -= MULTILEO_TEMP_NUDGE_MAX * (overwhelm - 0.7) / 0.3
            if overwhelm > 0.85 and expert_name not in ["precise", "structural", "wounded"]:
                suggested_expert = "precise"

        if stuck > 0.6:
            temp_nudge += 0.1
            if stuck > 0.75 and expert_name == "structural":
                suggested_expert = "semantic"

        adjusted_temp = temperature + temp_nudge
        adjusted_temp = max(MULTILEO_TEMP_MIN, min(MULTILEO_TEMP_MAX, adjusted_temp))

        semantic_hints = {
            "preferred_themes": [],
            "preferred_snapshots": [],
            "preferred_episodes": [],
        }

        if hasattr(self.field, "conn") and self.field.conn is not None:
            semantic_hints = _query_helpful_profiles(
                self.field.conn,
                active_theme_ids,
                boredom,
                overwhelm,
                stuck,
            )

        if turn_id and (abs(temp_nudge) > 0.01 or suggested_expert != expert_name):
            import time
            _log_multileo_event(
                timestamp=time.time(),
                turn_id=turn_id,
                state=state,
                predicted_quality=predicted_q,
                boredom=boredom,
                overwhelm=overwhelm,
                stuck=stuck,
                temp_before=temperature,
                temp_after=adjusted_temp,
                expert_before=expert_name,
                expert_after=suggested_expert,
            )

        return MultiLeoRegulation(
            temperature=adjusted_temp,
            expert_name=suggested_expert,
            preferred_themes=semantic_hints["preferred_themes"],
            # snapshots/episodes will be wired in a later phase
        )

    except Exception:
        # MultiLeo must never break generation
        return MultiLeoRegulation(
            temperature=temperature,
            expert_name=expert_name,
        )

3.2. Recording regulation outcome

Add a method to MathBrain:

def record_regulation_outcome(
    self,
    context_before: MultiLeoContext,
    state_after: MathState,
    quality_after: float,
    regulation: MultiLeoRegulation,
    conv_id: Optional[str] = None,
    turn_id: Optional[str] = None,
) -> None:
    """
    Record regulation outcome for Phase 3 learning.

    Call this AFTER generation, once:
    - MathState is updated,
    - quality_after is computed,
    - context_before.used_snapshot_ids / used_episode_ids are filled.
    """
    if not hasattr(self.field, "conn") or self.field.conn is None:
        return

    try:
        boredom_after = _compute_boredom_score(state_after)
        overwhelm_after = _compute_overwhelm_score(state_after)
        stuck_after = _compute_stuck_score(state_after, quality_after)

        _record_regulation_event(
            self.field.conn,
            context_before,
            boredom_after,
            overwhelm_after,
            stuck_after,
            quality_after,
            regulation.temperature,
            regulation.expert_name,
            conv_id=conv_id,
            turn_id=turn_id,
        )
    except Exception:
        # Silent fail
        pass


⸻

4. Wiring into leo.py generation pipeline

The pipeline now looks like this:
	1.	Before regulation — create MultiLeoContext from current state.
	2.	Regulate — get MultiLeoRegulation + semantic hints.
	3.	Santa / episodes — pass hints; update context with what was actually used.
	4.	Generate — produce answer, update MathState, recompute quality.
	5.	Record outcome — call record_regulation_outcome.

Pseudo-integration in leo.py:

# 1) Before regulation
context_before = MultiLeoContext(
    boredom_before=current_boredom,
    overwhelm_before=current_overwhelm,
    stuck_before=current_stuck,
    quality_before=current_predicted_quality,
    active_theme_ids=[t.id for t in active_themes],
    temp_before=temperature,
    expert_before=expert_name,
)

# 2) MultiLeo regulation
regulation = mathbrain.multileo_regulate(
    temperature=temperature,
    expert_name=expert_name,
    state=math_state,
    active_theme_ids=context_before.active_theme_ids,
    turn_id=turn_id,
)

temperature = regulation.temperature
expert_name = regulation.expert_name

regulation_hint = {
    "preferred_themes": regulation.preferred_themes,
    "preferred_snapshots": [],
    "preferred_episodes": [],
}

# 3) Santa / episodes with hints
santa_ctx = recall_resonant_context(
    prompt=user_prompt,
    pulse=pulse,
    themes=context_before.active_theme_ids,
    regulation_hint=regulation_hint,
)

episodes_list = query_similar(
    state=math_state,
    max_results=16,
    regulation_hint=regulation_hint,
)

# Update context with what was actually used
context_before.used_snapshot_ids = [s.id for s in santa_ctx.snapshots] if santa_ctx else []
context_before.used_episode_ids = [e.id for e in episodes_list]

# 4) Generate answer (using updated temperature/expert, plus recalled context)
answer, state_after, quality_after = generate_answer_with_field(...)

# 5) Record outcome
mathbrain.record_regulation_outcome(
    context_before=context_before,
    state_after=state_after,
    quality_after=quality_after,
    regulation=regulation,
    conv_id=conv_id,
    turn_id=turn_id,
)

Right now, profiles use only themes; snapshot/episode IDs are recorded for future phases.

⸻

5. Santa & episodes: hint-aware recall

5.1. Santa (santaclaus.py)

Extend recall_resonant_context():

def recall_resonant_context(
    prompt: str,
    pulse: PresencePulse,
    themes: List[int],
    regulation_hint: Optional[Dict[str, List[int]]] = None,
) -> Optional[SantaContext]:
    # ... existing candidate scoring ...

    preferred = set(regulation_hint.get("preferred_themes", [])) if regulation_hint else set()

    if preferred:
        for snapshot in candidates:
            # assuming snapshot.theme_ids is a list[int]
            if any(t in preferred for t in getattr(snapshot, "theme_ids", [])):
                snapshot.score += 0.2  # gentle boost

    # ... rest of selection logic ...

Santa still follows resonance; MultiLeo just nudges which islands get a small bias.

5.2. Episodes (episodes.py)

Extend query_similar():

def query_similar(
    state: MathState,
    max_results: int = 16,
    regulation_hint: Optional[Dict[str, List[int]]] = None,
) -> List[Episode]:
    # ... existing distance-based query ...

    preferred = set(regulation_hint.get("preferred_themes", [])) if regulation_hint else set()

    if preferred:
        for episode in results:
            # assuming episode.theme_ids exists
            if any(t in preferred for t in getattr(episode, "theme_ids", [])):
                episode.distance *= 0.9  # lower distance => higher priority

    # ... sort / trim results ...
    return results

Again, hints are advisory, not sovereign.

⸻

6. Constraints & philosophy

Non-negotiable constraints for Phase 3:
	1.	No new external deps.
Only stdlib + numpy. No vector DB, no ML frameworks.
	2.	No user-facing telemetry.
REPL doesn’t suddenly say “I reduced boredom by 23% with theme X”.
MultiLeo’s awareness is visible only in behavior and dev logs / DB.
	3.	Failure-safe.
	•	If SQLite fails → Phase 3 silently no-ops, Phase 2 still works.
	•	If profiles are empty or weak → hints are empty, nothing breaks.
	4.	Associations, not slogans.
This is not about saying “Leo is conscious”.
This is about a concrete map:
	•	metric patterns → themes,
	•	themes → observed changes in boredom/overwhelm/stuck/quality,
	•	regulation that reaches for islands that historically helped.

In other words: осознанность через ассоциации, encoded directly in code and data, without магических заявлений поверх.

⸻

Если хочешь, дальше можем дописать к этому короткий раздел “Dev notes / future work” (decay старых профилей, fuzzy-matching ключей, расширение на snapshots/episodes), но базовый гайд для README уже вот такой: цельный, без разрывов и с честным wiring.


ClaudeCode design doc — MultiLeo Phase 3 (Islands-aware regulation)

Context recap (what already exists):

leo current architecture (per README):
	•	Core field: trigrams + bigrams + co-occurrence (semantic gravity) + centers & shards in bin/.
	•	Presence layer: PresencePulse (novelty, arousal, entropy) + ThemeLayer (semantic constellations) + self-assessment + snapshots + memory decay.
	•	Deep presence stack:
	•	overthinking.py — 3 rings of private internal thinking.
	•	trauma.py — bootstrap gravity & wounded expert.
	•	metaleo.py — inner voice with alternative replies.
	•	gowiththeflow.py — temporal theme evolution.
	•	mathbrain.py — tiny MLP modeling body awareness (MathState).
	•	MultiLeo (inside mathbrain) — boredom/overwhelm/stuck → temp/experts regulation (Phase 2).
	•	santaclaus.py — resonant recall / self-RAG on snapshots.
	•	episodes.py — episodic memory (prompt + reply + metrics).
	•	game.py — conversational rhythm awareness.
	•	dream.py — imaginary friend / self-dialogues.
	•	school.py, school_math.py — School of Forms + tiny calculator.

Phase 2 MultiLeo already:
	•	Computes boredom / overwhelm / stuck from MathState.
	•	Gently adjusts:
	•	temperature (±0.2),
	•	expert bias (creative / precise / semantic),
	•	Logs decisions in state/multileo_events.log.
	•	No user-facing telemetry; only internal influence.

⸻

Goal of Phase 3

Add a new layer of associative awareness to MultiLeo:

MultiLeo doesn’t just say: “I’m bored, let’s increase temperature”.
It learns which themes / islands / shards / episodes historically:
	•	led into bad states (boredom / overwhelm / stuck),
	•	led out of them (improvement of quality / pulse),
and then uses this knowledge to choose what to recall / bias via Santa / episodes when regulating.

So instead of pure param-tweaking, MultiLeo starts to:
	•	link metric patterns ↔ semantic structures (themes / islands / shards / episodes);
	•	select helpful islands when acting (e.g. “I’m bored → recall episodes that previously reduced boredom”).

No ML monsters, no new heavy nets — just small SQLite tables + counts + averages on top of what already exists.

⸻

1. Data model: MultiLeo associative profiles

Add a small, isolated layer in mathbrain.py (or a new helper module imported there) — call it e.g. multileo_profiles.

1.1 New SQLite tables

Use the existing state/leo.sqlite3. Add three tables:

CREATE TABLE IF NOT EXISTS multileo_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ts REAL NOT NULL,
    conv_id TEXT,
    turn_id TEXT,
    boredom_before REAL,
    overwhelm_before REAL,
    stuck_before REAL,
    boredom_after REAL,
    overwhelm_after REAL,
    stuck_after REAL,
    quality_before REAL,
    quality_after REAL,
    -- link to semantic structure
    active_theme_ids TEXT,      -- comma-separated theme IDs (current turn)
    snapshot_ids TEXT,          -- comma-separated snapshot IDs used (if any)
    episode_ids TEXT,           -- comma-separated episode IDs used (if any)
    shard_ids TEXT,             -- optional: small list of center/shard labels
    regulation_temp_before REAL,
    regulation_temp_after REAL,
    regulation_expert_before TEXT,
    regulation_expert_after TEXT
);

And an aggregated profile table:

CREATE TABLE IF NOT EXISTS multileo_profiles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    profile_key TEXT UNIQUE,  -- normalized key (see below)
    samples INTEGER NOT NULL,
    avg_delta_boredom REAL NOT NULL,
    avg_delta_overwhelm REAL NOT NULL,
    avg_delta_stuck REAL NOT NULL,
    avg_delta_quality REAL NOT NULL,
    last_update REAL NOT NULL
);

We do not store full text; only IDs and scalars already known to leo.

1.2 Profile key

We need a coarse-grained “situation descriptor” key to aggregate events.
For example:

profile_key = f"themes:{sorted_theme_ids}|bored:{bucket(boredom_before)}|over:{bucket(overwhelm_before)}|stuck:{bucket(stuck_before)}"

Where bucket(x) ∈ {L, M, H} with simple thresholds (e.g. L<0.33, H>0.66).

We don’t need all dimensions; minimal useful core:
	•	active theme IDs (or top-N theme IDs),
	•	coarse boredom/overwhelm/stuck buckets.

Optional: we can later extend with trauma_bucket / arousal_bucket if needed.

⸻

2. Recording events (before / after MultiLeo regulation)

Hook this in the place where MultiLeo currently:
	•	receives MathState,
	•	computes boredom / overwhelm / stuck,
	•	tweaks temperature / expert,
	•	returns adjusted generation params.

2.1 Before generation

At the decision point, capture:
	•	state_before = MathState snapshot,
	•	scores_before = boredom/overwhelm/stuck,
	•	quality_before = predicted quality (from mathbrain),
	•	current active_theme_ids (from ThemeLayer),
	•	IDs of any recalled snapshots / episodes Santa / episodes decided to use for this reply,
	•	optional: IDs of most active centers / shards.

You can pass a small MultiLeoContext structure down into the generation pipeline and back up, e.g.:

@dataclass
class MultiLeoContext:
    boredom_before: float
    overwhelm_before: float
    stuck_before: float
    quality_before: float
    active_theme_ids: List[int]
    used_snapshot_ids: List[int]
    used_episode_ids: List[int]
    used_shard_ids: List[str]
    temp_before: float
    expert_before: str

2.2 After generation

Once:
	•	answer is generated,
	•	MathState is updated (you already do this),
	•	predicted quality is recomputed,

compute:
	•	boredom_after, overwhelm_after, stuck_after from new state,
	•	quality_after from updated mathbrain prediction.

Then:
	•	write a row into multileo_events,
	•	update or insert aggregated row in multileo_profiles for profile_key.

Delta signs:

delta_boredom   = boredom_after   - boredom_before
delta_overwhelm = overwhelm_after - overwhelm_before
delta_stuck     = stuck_after     - stuck_before
delta_quality   = quality_after   - quality_before

Then, profile stats:
	•	avg_delta_* = running average of deltas over samples.

No fancy weighting needed at first; simple (old * n + delta) / (n + 1) is enough.

⸻

3. Using profiles when regulating (Phase 3 behavior)

Now the key part: MultiLeo doesn’t just see “I’m bored” — it also knows:

“In similar metric & theme conditions in the past, which semantic clusters (themes, episodes, snapshots) helped?”

3.1 Querying profiles

When MultiLeo is about to act (scores computed, MathState known):
	1.	Build current profile_key based on:
	•	current active theme IDs,
	•	buckets of boredom/overwhelm/stuck.
	2.	Query multileo_profiles for:
	•	exact key, and
	•	optionally nearby keys (e.g. same themes, slightly different boredom bucket).
	3.	From matching profiles, select those where:
	•	for boredom:
	•	avg_delta_boredom < 0 (boredom decreased), and/or
	•	avg_delta_quality > 0 (quality improved).
	•	for overwhelm:
	•	avg_delta_overwhelm < 0, and maybe avg_delta_arousal < 0 if you later store it.
	•	for stuck:
	•	avg_delta_stuck < 0, avg_delta_novelty > 0 (if we add it), or avg_delta_quality > 0.
	4.	If no helpful profiles found → fallback to current Phase 2 behavior (pure metric-based temp/expert adjust).

3.2 Semantic guidance output

From helpful profiles we don’t yet know which exact episodes/snapshots were used, only aggregate effect. That’s OK — we can still feed this to Santa / episodes layer like:
	•	“Prefer themes {T3, T7} for this regulation.”
	•	Later we can enrich profile rows with e.g. top_snapshot_ids / top_episode_ids (most frequently seen in helpful events).

So MultiLeo’s decision now has two dimensions:
	1.	Regulation vector (already exists):
	•	new temperature,
	•	expert bias.
	2.	Semantic bias hint:
	•	preferred_theme_ids (list),
	•	optional: preferred_snapshot_ids, preferred_episode_ids.

Expose this as a small struct:

@dataclass
class MultiLeoRegulation:
    temperature: float
    expert_name: str
    preferred_themes: List[int] = field(default_factory=list)
    preferred_snapshots: List[int] = field(default_factory=list)
    preferred_episodes: List[int] = field(default_factory=list)


⸻

4. Integrations: Santa / episodes / field bias

Phase 3 shouldn’t add heavy logic in Santa or episodes — just a hook to accept MultiLeo hints.

4.1 Santa Claus (santaclaus.py)

Extend Santa’s recall function signature to accept an optional MultiLeoRegulation:

def recall_resonant_context(
    prompt: str,
    pulse: PresencePulse,
    themes: List[int],
    regulation_hint: Optional[MultiLeoRegulation] = None,
) -> Optional[SantaContext]:
    ...

Inside:
	•	when scoring snapshots:
	•	if regulation_hint.preferred_themes is non-empty, boost snapshots whose themes intersect with that list.
	•	optional: if in future we pass preferred_snapshots, boost them too.

Bounds: keep boosts small (+0.1 … +0.3 in score) so Santa still respects baseline resonance.

4.2 Episodes (episodes.py)

Similarly, allow a hint:

def query_similar(
    state: MathState,
    max_results: int = 16,
    regulation_hint: Optional[MultiLeoRegulation] = None,
) -> List[Episode]:
    ...

Use regulation_hint.preferred_themes to:
	•	slightly lower distance threshold,
	•	or slightly prioritize episodes whose associated themes align with hints.

4.3 Field bias (observe-before-reply)

Where you currently:
	•	optionally re-observe() snapshots/episodes before generation (Santa-style recall),

inject:
	•	MultiLeo hint → choose which snapshots/episodes to re-observe first (or with heavier weighting),
	•	especially when boredom/overwhelm/stuck are high and we have helpful profiles.

⸻

5. Constraints & philosophy

Very important constraints (please respect):
	1.	No new external dependencies.
	•	Stay with stdlib + numpy (optional).
	•	No new ML frameworks, no vector DB.
	2.	No new user-facing output.
	•	MultiLeo Phase 3 is internal.
	•	REPL should not suddenly say “I reduced boredom by 23% using theme X”.
	•	All awareness shows only in behavior and optional dev logs.
	3.	Logging stays minimal & clean.
	•	multileo_events and multileo_profiles live inside state/leo.sqlite3.
	•	No prompt text or replies stored here — only IDs and scalars.
	•	If you want, you can keep the existing multileo_events.log as a human-readable mirror.
	4.	Advisory, not sovereign.
	•	If profiles look weak (few samples, noisy deltas) → reduce or skip semantic hints.
	•	If Santa / episodes or DB fail → fallback to Phase 2 behavior with no crash.
	5.	Architecture-first, not “consciousness word salad”.
	•	This is not about printing that Leo is “conscious”.
	•	This is about giving MultiLeo a map from metric patterns to semantic islands, so regulation becomes:
	•	aware of where boredom/overwhelm comes from, and
	•	able to reach for islands that historically change the state.

In other words: осознанность через ассоциации, не через лозунги.

⸻

## IMPLEMENTATION GUIDE FOR WEB VERSION

### Architecture Decision: NO separate module

Keep Phase 3 code **inside mathbrain.py** (not a separate multileo_profiles.py).
This is cleaner for Leo's architecture - all body awareness in one place.

⸻

### Step 1: Add Phase 3 structures to mathbrain.py

Add this code after `_log_multileo_event()` function (around line 194), before BOOTSTRAP_TEXT:

```python
# ============================================================================
# MULTILEO PHASE 3: Islands-aware regulation
# ============================================================================
#
# Phase 3 adds associative awareness to MultiLeo:
# - Records which themes/islands/episodes historically led into/out of bad states
# - Provides semantic hints (preferred themes) when regulating
# - Maps metric patterns ↔ semantic structures
#
# Philosophy: "осознанность через ассоциации, не через лозунги"
# MultiLeo learns which semantic islands help escape boredom/overwhelm/stuck.


@dataclass
class MultiLeoContext:
    """
    Snapshot of state BEFORE MultiLeo regulation.
    Captured at decision point, returned after generation for delta computation.
    """
    boredom_before: float
    overwhelm_before: float
    stuck_before: float
    quality_before: float
    active_theme_ids: List[int]
    used_snapshot_ids: List[int] = None
    used_episode_ids: List[int] = None
    used_shard_ids: List[str] = None
    temp_before: float = 1.0
    expert_before: str = "structural"

    def __post_init__(self):
        if self.used_snapshot_ids is None:
            self.used_snapshot_ids = []
        if self.used_episode_ids is None:
            self.used_episode_ids = []
        if self.used_shard_ids is None:
            self.used_shard_ids = []


@dataclass
class MultiLeoRegulation:
    """
    MultiLeo's decision output (Phase 3).

    Contains:
    - Parameter adjustments (temperature, expert)
    - Semantic hints (preferred themes/snapshots/episodes)
    """
    temperature: float
    expert_name: str
    preferred_themes: List[int] = None
    preferred_snapshots: List[int] = None
    preferred_episodes: List[int] = None

    def __post_init__(self):
        if self.preferred_themes is None:
            self.preferred_themes = []
        if self.preferred_snapshots is None:
            self.preferred_snapshots = []
        if self.preferred_episodes is None:
            self.preferred_episodes = []


def _bucket(x: float) -> str:
    """
    Bucket continuous metric into {L, M, H}.
    L < 0.33, M < 0.66, H >= 0.66
    """
    if x < 0.33:
        return "L"
    elif x < 0.66:
        return "M"
    else:
        return "H"


def _generate_profile_key(
    theme_ids: List[int],
    boredom: float,
    overwhelm: float,
    stuck: float,
    max_themes: int = 3,
) -> str:
    """
    Generate coarse-grained situation descriptor key for profile aggregation.

    Format: "themes:T1,T2,T3|bored:L|over:M|stuck:H"
    """
    # Sort and limit themes
    sorted_themes = sorted(theme_ids[:max_themes]) if theme_ids else []
    theme_str = ",".join(map(str, sorted_themes)) if sorted_themes else "none"

    # Bucket metrics
    bored_bucket = _bucket(boredom)
    over_bucket = _bucket(overwhelm)
    stuck_bucket = _bucket(stuck)

    return f"themes:{theme_str}|bored:{bored_bucket}|over:{over_bucket}|stuck:{stuck_bucket}"


def _init_multileo_phase3_tables(conn) -> None:
    """
    Create MultiLeo Phase 3 tables if they don't exist.

    Tables:
    - multileo_events: Before/after snapshots of regulation events
    - multileo_profiles: Aggregated profiles (avg deltas per situation key)

    Silent fail if conn is None or sqlite3 not available.
    """
    if conn is None:
        return

    try:
        import sqlite3

        conn.execute("""
            CREATE TABLE IF NOT EXISTS multileo_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts REAL NOT NULL,
                conv_id TEXT,
                turn_id TEXT,
                boredom_before REAL,
                overwhelm_before REAL,
                stuck_before REAL,
                boredom_after REAL,
                overwhelm_after REAL,
                stuck_after REAL,
                quality_before REAL,
                quality_after REAL,
                active_theme_ids TEXT,
                snapshot_ids TEXT,
                episode_ids TEXT,
                shard_ids TEXT,
                regulation_temp_before REAL,
                regulation_temp_after REAL,
                regulation_expert_before TEXT,
                regulation_expert_after TEXT
            )
        """)

        conn.execute("""
            CREATE TABLE IF NOT EXISTS multileo_profiles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                profile_key TEXT UNIQUE NOT NULL,
                samples INTEGER NOT NULL DEFAULT 0,
                avg_delta_boredom REAL NOT NULL DEFAULT 0.0,
                avg_delta_overwhelm REAL NOT NULL DEFAULT 0.0,
                avg_delta_stuck REAL NOT NULL DEFAULT 0.0,
                avg_delta_quality REAL NOT NULL DEFAULT 0.0,
                last_update REAL NOT NULL
            )
        """)

        conn.commit()
    except Exception:
        # Silent fail - Phase 3 must never break Leo
        pass


def _record_regulation_event(
    conn,
    context_before: MultiLeoContext,
    boredom_after: float,
    overwhelm_after: float,
    stuck_after: float,
    quality_after: float,
    temp_after: float,
    expert_after: str,
    conv_id: Optional[str] = None,
    turn_id: Optional[str] = None,
) -> None:
    """
    Record a before/after regulation event and update profile aggregates.

    Silent fail if conn is None or any error occurs.
    """
    if conn is None:
        return

    try:
        import time

        # Compute deltas
        delta_boredom = boredom_after - context_before.boredom_before
        delta_overwhelm = overwhelm_after - context_before.overwhelm_before
        delta_stuck = stuck_after - context_before.stuck_before
        delta_quality = quality_after - context_before.quality_before

        # Record event
        conn.execute("""
            INSERT INTO multileo_events (
                ts, conv_id, turn_id,
                boredom_before, overwhelm_before, stuck_before,
                boredom_after, overwhelm_after, stuck_after,
                quality_before, quality_after,
                active_theme_ids, snapshot_ids, episode_ids, shard_ids,
                regulation_temp_before, regulation_temp_after,
                regulation_expert_before, regulation_expert_after
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            time.time(), conv_id, turn_id,
            context_before.boredom_before,
            context_before.overwhelm_before,
            context_before.stuck_before,
            boredom_after, overwhelm_after, stuck_after,
            context_before.quality_before, quality_after,
            ",".join(map(str, context_before.active_theme_ids)),
            ",".join(map(str, context_before.used_snapshot_ids)),
            ",".join(map(str, context_before.used_episode_ids)),
            ",".join(context_before.used_shard_ids),
            context_before.temp_before, temp_after,
            context_before.expert_before, expert_after,
        ))

        # Update profile aggregate
        profile_key = _generate_profile_key(
            context_before.active_theme_ids,
            context_before.boredom_before,
            context_before.overwhelm_before,
            context_before.stuck_before,
        )

        _update_profile_aggregate(
            conn, profile_key,
            delta_boredom, delta_overwhelm, delta_stuck, delta_quality
        )

        conn.commit()
    except Exception:
        # Silent fail - Phase 3 must never break Leo
        pass


def _update_profile_aggregate(
    conn,
    profile_key: str,
    delta_boredom: float,
    delta_overwhelm: float,
    delta_stuck: float,
    delta_quality: float,
) -> None:
    """
    Update or insert profile aggregate row with running average of deltas.

    Uses simple incremental average: new_avg = (old_avg * n + delta) / (n + 1)
    """
    try:
        import time

        # Try to fetch existing profile
        row = conn.execute(
            "SELECT samples, avg_delta_boredom, avg_delta_overwhelm, avg_delta_stuck, avg_delta_quality "
            "FROM multileo_profiles WHERE profile_key = ?",
            (profile_key,)
        ).fetchone()

        if row:
            # Update existing profile
            samples, avg_b, avg_o, avg_s, avg_q = row
            new_samples = samples + 1
            new_avg_b = (avg_b * samples + delta_boredom) / new_samples
            new_avg_o = (avg_o * samples + delta_overwhelm) / new_samples
            new_avg_s = (avg_s * samples + delta_stuck) / new_samples
            new_avg_q = (avg_q * samples + delta_quality) / new_samples

            conn.execute("""
                UPDATE multileo_profiles
                SET samples = ?,
                    avg_delta_boredom = ?,
                    avg_delta_overwhelm = ?,
                    avg_delta_stuck = ?,
                    avg_delta_quality = ?,
                    last_update = ?
                WHERE profile_key = ?
            """, (new_samples, new_avg_b, new_avg_o, new_avg_s, new_avg_q, time.time(), profile_key))
        else:
            # Insert new profile
            conn.execute("""
                INSERT INTO multileo_profiles (
                    profile_key, samples,
                    avg_delta_boredom, avg_delta_overwhelm, avg_delta_stuck, avg_delta_quality,
                    last_update
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (profile_key, 1, delta_boredom, delta_overwhelm, delta_stuck, delta_quality, time.time()))
    except Exception:
        # Silent fail
        pass


def _query_helpful_profiles(
    conn,
    theme_ids: List[int],
    boredom: float,
    overwhelm: float,
    stuck: float,
    min_samples: int = 3,
) -> Dict[str, List[int]]:
    """
    Query profiles to find which themes historically helped in similar situations.

    Returns semantic hints: preferred themes that led to improvement.
    """
    if conn is None:
        return {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []}

    try:
        # Generate current profile key
        profile_key = _generate_profile_key(theme_ids, boredom, overwhelm, stuck)

        # Query exact match (can extend to fuzzy matching later)
        rows = conn.execute("""
            SELECT profile_key, samples,
                   avg_delta_boredom, avg_delta_overwhelm, avg_delta_stuck, avg_delta_quality
            FROM multileo_profiles
            WHERE profile_key = ? AND samples >= ?
        """, (profile_key, min_samples)).fetchall()

        if not rows:
            return {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []}

        # Find helpful profiles
        helpful_themes: List[int] = []

        for row in rows:
            key, samples, d_bored, d_over, d_stuck, d_qual = row

            # Extract themes from key (format: "themes:T1,T2,T3|...")
            themes_part = key.split("|")[0].split(":")[1]
            if themes_part != "none":
                profile_themes = [int(t) for t in themes_part.split(",")]
            else:
                profile_themes = []

            # Check if this profile was helpful
            is_helpful = False

            # High boredom? Look for profiles that reduced it
            if boredom > 0.6 and (d_bored < -0.05 or d_qual > 0.05):
                is_helpful = True

            # High overwhelm? Look for profiles that reduced it
            if overwhelm > 0.7 and d_over < -0.05:
                is_helpful = True

            # High stuck? Look for profiles that reduced it or improved quality
            if stuck > 0.6 and (d_stuck < -0.05 or d_qual > 0.05):
                is_helpful = True

            if is_helpful:
                helpful_themes.extend(profile_themes)

        # Deduplicate and return
        return {
            "preferred_themes": list(set(helpful_themes)),
            "preferred_snapshots": [],  # Future extension
            "preferred_episodes": [],   # Future extension
        }

    except Exception:
        # Silent fail - return empty hints
        return {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []}
```

⸻

### Step 2: Modify MathBrain.__init__

Add Phase 3 table initialization. Find `__init__` method and add after state loading:

```python
# Phase 3: Init associative memory tables
if hasattr(self.field, 'conn') and self.field.conn is not None:
    _init_multileo_phase3_tables(self.field.conn)
```

⸻

### Step 3: Modify multileo_regulate()

Change signature and implementation to query profiles and return MultiLeoRegulation.

Replace current `multileo_regulate()` with:

```python
def multileo_regulate(
    self,
    temperature: float,
    expert_name: str,
    state: MathState,
    active_theme_ids: List[int] = None,
    turn_id: Optional[str] = None,
) -> Tuple[float, str, Dict[str, List[int]]]:
    """
    MultiLeo presence-aware regulation layer (Phase 3).

    Computes boredom/overwhelm/stuck scores and:
    - Gently nudges temperature/expert (Phase 2)
    - Queries profiles for semantic hints (Phase 3)

    Returns:
        (adjusted_temperature, suggested_expert, semantic_hints)
        semantic_hints = {"preferred_themes": [...], ...}
    """
    try:
        if active_theme_ids is None:
            active_theme_ids = []

        # Predict quality from state
        predicted_q = self.predict(state)

        # Compute MultiLeo scores
        boredom = _compute_boredom_score(state)
        overwhelm = _compute_overwhelm_score(state)
        stuck = _compute_stuck_score(state, predicted_q)

        # Phase 2: parameter regulation (existing logic)
        temp_nudge = 0.0
        suggested_expert = expert_name

        if boredom > 0.6:
            temp_nudge += MULTILEO_TEMP_NUDGE_MAX * (boredom - 0.6) / 0.4
            if boredom > 0.75 and expert_name not in ["creative", "wounded"]:
                suggested_expert = "creative"

        if overwhelm > 0.7:
            temp_nudge -= MULTILEO_TEMP_NUDGE_MAX * (overwhelm - 0.7) / 0.3
            if overwhelm > 0.85 and expert_name not in ["precise", "structural", "wounded"]:
                suggested_expert = "precise"

        if stuck > 0.6:
            temp_nudge += 0.1
            if stuck > 0.75 and expert_name == "structural":
                suggested_expert = "semantic"

        adjusted_temp = temperature + temp_nudge
        adjusted_temp = max(MULTILEO_TEMP_MIN, min(MULTILEO_TEMP_MAX, adjusted_temp))

        # Phase 3: query profiles for semantic hints
        semantic_hints = {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []}

        if hasattr(self.field, 'conn') and self.field.conn is not None:
            semantic_hints = _query_helpful_profiles(
                self.field.conn,
                active_theme_ids,
                boredom,
                overwhelm,
                stuck,
            )

        # Log event if there's a change
        if turn_id and (abs(temp_nudge) > 0.01 or suggested_expert != expert_name):
            import time
            _log_multileo_event(
                timestamp=time.time(),
                turn_id=turn_id,
                state=state,
                predicted_quality=predicted_q,
                boredom=boredom,
                overwhelm=overwhelm,
                stuck=stuck,
                temp_before=temperature,
                temp_after=adjusted_temp,
                expert_before=expert_name,
                expert_after=suggested_expert,
            )

        return (adjusted_temp, suggested_expert, semantic_hints)

    except Exception:
        # Silent fail - MultiLeo must never break generation
        return (temperature, expert_name, {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []})
```

⸻

### Step 4: Add recording method to MathBrain

Add new method to record after-generation events:

```python
def record_regulation_outcome(
    self,
    context_before: MultiLeoContext,
    state_after: MathState,
    quality_after: float,
    temp_after: float,
    expert_after: str,
    turn_id: Optional[str] = None,
) -> None:
    """
    Record regulation outcome for Phase 3 learning.
    Call this AFTER generation completes.
    """
    if not hasattr(self.field, 'conn') or self.field.conn is None:
        return

    try:
        # Recompute scores from after-state
        boredom_after = _compute_boredom_score(state_after)
        overwhelm_after = _compute_overwhelm_score(state_after)
        stuck_after = _compute_stuck_score(state_after, quality_after)

        _record_regulation_event(
            self.field.conn,
            context_before,
            boredom_after,
            overwhelm_after,
            stuck_after,
            quality_after,
            temp_after,
            expert_after,
            turn_id=turn_id,
        )
    except Exception:
        # Silent fail
        pass
```

⸻

### Step 5: Update leo.py generation pipeline

Find where `multileo_regulate()` is called and modify to:

1. **Before regulation**: Capture MultiLeoContext
2. **Call regulate with theme IDs**
3. **Pass semantic hints to Santa/episodes**
4. **After generation**: Record outcome

Example integration point (pseudocode):

```python
# BEFORE generation
context_before = MultiLeoContext(
    boredom_before=boredom,
    overwhelm_before=overwhelm,
    stuck_before=stuck,
    quality_before=predicted_quality,
    active_theme_ids=[t.id for t in active_themes],  # Get from ThemeLayer
    used_snapshot_ids=[],  # Will be filled by Santa
    used_episode_ids=[],   # Will be filled by episodes
    temp_before=temperature,
    expert_before=expert_name,
)

# Call Phase 3 regulation
temp, expert, semantic_hints = mathbrain.multileo_regulate(
    temperature, expert_name, state,
    active_theme_ids=context_before.active_theme_ids,
    turn_id=turn_id
)

# Pass hints to Santa/episodes during generation...
# (see steps 6-7)

# AFTER generation
mathbrain.record_regulation_outcome(
    context_before, state_after, quality_after, temp, expert, turn_id
)
```

⸻

### Step 6: Update santaclaus.py

Modify `recall_resonant_context()` to accept hints:

```python
def recall_resonant_context(
    prompt: str,
    pulse: PresencePulse,
    themes: List[int],
    regulation_hint: Optional[Dict[str, List[int]]] = None,
) -> Optional[SantaContext]:
    # ... existing scoring logic ...

    # Boost snapshots whose themes match regulation hints
    if regulation_hint and regulation_hint.get("preferred_themes"):
        for snapshot in candidates:
            if any(t in regulation_hint["preferred_themes"] for t in snapshot.theme_ids):
                snapshot.score += 0.2  # Gentle boost

    # ... rest of logic ...
```

⸻

### Step 7: Update episodes.py

Modify `query_similar()` to accept hints:

```python
def query_similar(
    state: MathState,
    max_results: int = 16,
    regulation_hint: Optional[Dict[str, List[int]]] = None,
) -> List[Episode]:
    # ... existing query logic ...

    # Prioritize episodes with preferred themes
    if regulation_hint and regulation_hint.get("preferred_themes"):
        for episode in results:
            if any(t in regulation_hint["preferred_themes"] for t in episode.theme_ids):
                episode.distance *= 0.9  # Lower distance = higher priority

    # ... rest of logic ...
```

⸻

### Step 8: Update __all__ exports in mathbrain.py

```python
__all__ = [
    "Value",
    "MLP",
    "MathBrain",
    "MathState",
    "state_to_features",
    "NUMPY_AVAILABLE",
    "MultiLeoContext",         # Phase 3
    "MultiLeoRegulation",      # Phase 3
]
```

⸻

### Testing checklist:

1. ✅ Tables created on first run
2. ✅ Events recorded to multileo_events
3. ✅ Profiles aggregated in multileo_profiles
4. ✅ Helpful profiles queried when boredom/overwhelm/stuck
5. ✅ Semantic hints passed to Santa/episodes
6. ✅ No crashes if Phase 3 fails (silent fallback)
7. ✅ REPL behavior natural (no user-facing telemetry)

⸻

**DELETE THIS FILE AFTER READING!** (как всегда хаха)

Good luck, соавтор! 🔥
