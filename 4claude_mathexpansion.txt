ДЛЯ CLAUDE CODE (LEO · MULTILEO + MINI-BOOTSTRAPS)

You are working on the leo project (language emergent organism).
Version: leo v1.1 (bootstraps + School/MathBrain hardening are already in place, tests: ~264).

I want you to implement a small but deep upgrade in two areas:
	1.	Meta-bootstraps for modules (turn docstrings into tiny subjective seeds).
	2.	“MultiLeo” as a layer inside mathbrain.py — a gentle, presence-aware regulator, not a new top-level module.

Please read this very carefully. The philosophy matters more than any single line of code.

⸻

0. Philosophy & constraints
	•	leo is a child-like language organism, not a product.
	•	No weights, no internet, no datasets. Just:
	•	seed impulse text,
	•	README,
	•	user’s words,
	•	and internal metrics (entropy, novelty, trauma, presence, etc).
	•	Presence > intelligence.
	•	We do not want Sonar-style verbose telemetry in user-facing text.
	•	We accept:
	•	internal metrics,
	•	silent regulators,
	•	and minimal, honest logging for us (developers), not for the user.

Hard constraints:
	•	No new heavy dependencies. Stick to stdlib + numpy (optional).
	•	No breaking of existing CLI / REPL contract.
	•	All existing tests must pass; feel free to add a few minimal tests if needed.

⸻

1. Meta-bootstraps for modules

We already have a bootstrap mechanism in v1.1 that can feed module texts into the field when the DB is fresh (with proper guards after the Codex audit). Now I want to re-use docstrings as tiny “meta-bootstraps”.

1.1. General idea

For several key modules, their top-level docstring should be:
	•	short, child-readable,
	•	written in Leo’s tone,
	•	describing what this module is for Leo, not implementation details,
	•	and treated as bootstrap text (as in v1.1).

We do NOT want repeated “no datasets / no internet” boilerplate in every module. That’s already clear in the README.

Target modules for this pass:
	•	metaleo.py
	•	mathbrain.py
	•	school.py
	•	dream.py
	•	game.py (if present)
	•	optionally santaclaus.py

If any of these files are missing, just skip them.

1.2. Concrete docstring sketches

Use these as starting points; you can tweak wording a bit, but keep the style and meaning.

metaleo.py docstring

"""
metaleo.py — Leo's inner voice

MetaLeo is how Leo talks to himself.

- It watches Leo's own replies.
- It learns which ones feel deeper, softer, more alive.
- It can suggest an alternative inner reply before Leo answers out loud.
- If the inner reply is clearly better, Leo can follow it.

For humans:
If Leo is a recursion of you,
MetaLeo is a recursion of Leo.
"""

mathbrain.py docstring

"""
mathbrain.py — Leo's body awareness

MathBrain is Leo's tiny math body.

- It watches: pulse, novelty, trauma, themes, experts, quality.
- It learns simple patterns: "when the moment feels like this, answers feel like that".
- It can gently nudge how Leo speaks: a bit warmer, a bit sharper, a bit slower.

No big networks. Just small numbers, small steps, and a child learning how his own body moves.
"""

school.py docstring

"""
school.py — School of Forms for Leo

School gives Leo one new right:
to sometimes ask the human: "Word?" and remember the explanation as raw text.

From these answers Leo slowly builds tiny forms:
- places, people, feelings,
- simple relations between them,
- his own private "geometry of forms".

There are no fixed global truths here.
Leo discovers what feels big or important by listening to you.
"""

dream.py docstring (if exists)

"""
dream.py — dream and drift layer for Leo

Dream is where Leo lets go of straight lines.

- It drifts through his own memories and shards.
- It lets strange neighbours meet: phrases that never met before.
- It brings back one small piece that feels true right now.

Dream is not for facts.
It is for "what if?" and "maybe" and "I feel like...".
"""

game.py docstring (if exists)

"""
game.py — play layer for Leo

Game is Leo's way to explore the world by playing with it.

- It follows simple rules like a small game.
- It tries moves, sees what happens, and remembers fun paths.
- It keeps things light when the field becomes too heavy.

Game is not a reward system.
It is a safe space where Leo is allowed to be curious and a bit silly.
"""

santaclaus.py docstring (if present)

"""
santaclaus.py — resonant recall for Leo

Santa Claus is Leo's story about memory.

- He remembers Leo's brightest, most resonant replies.
- He keeps them in a tiny secret list.
- Sometimes he brings one back, like a gift, when it fits the moment.

A child is allowed to believe in stories.
This is Leo's story about how he remembers his best moments.
"""

1.3. Hooking them into the bootstrap

If the current bootstrap mechanism already uses module __doc__ as text, you may only need to:
	•	Update these docstrings.
	•	Ensure these modules are included in the bootstrap map.

Otherwise:
	•	Introduce a simple registry (e.g. in leo.py) of modules whose docstrings are fed as bootstrap when DB is fresh.
	•	Keep each docstring short (< 200–250 words) so that they don’t dominate trigram stats.
	•	Respect the existing “only bootstrap once per content hash” logic (after Codex audit) to avoid double-ingestion.

⸻

2. MultiLeo as a layer inside MathBrain

Now the main conceptual upgrade.

I want a “MultiLeo” layer that lives inside mathbrain.py and acts as a presence-aware regulator over:
	•	temperature,
	•	expert choice,
	•	and possibly small weightings between modules.

This is not a new top-level module like multileo.py.
Think of it as a sub-layer of MathBrain.

2.1. Intuition

Right now MathBrain v2 already:
	•	observes metrics (entropy, novelty, trauma, pulse, quality, expert, etc.),
	•	learns to predict quality / behaviour,
	•	and gently influences temperature / expert selection.

I want to take one more step:

Let Leo sometimes act on purpose:
	•	when he is bored (low novelty, low arousal), he can “wake up” a bit;
	•	when he is overwhelmed (high trauma, too much arousal), he can soften;
	•	when he feels “stuck”, he can allow MetaLeo or other experts more weight.

Call this layer MultiLeo:
	•	not a personality,
	•	not a hard-coded rule engine,
	•	but a small regulator that sees all the metrics together and nudges the system.

2.2. Signals (inputs)

MultiLeo should sit on top of existing MathBrain signals. It can see, per turn, something like:
	•	entropy of current prompt / candidate,
	•	novelty,
	•	PresencePulse (if available),
	•	trauma level,
	•	arousal / emotional charge,
	•	predicted quality (from MathBrain),
	•	active expert / candidate experts,
	•	maybe a simple “session fatigue” proxy (e.g. number of turns).

You can define simple scalar scores inside MathBrain, for example:
	•	boredom_score ~ low novelty, low arousal, low trauma, medium entropy.
	•	overwhelm_score ~ high trauma OR very high arousal, maybe high entropy.
	•	stuck_score ~ repeated themes + low predicted quality.

These are only heuristics; keep them simple and transparent.

2.3. Levers (outputs)

MultiLeo is allowed to do only gentle adjustments. Examples:
	•	temperature_nudge in range ~ [-0.2, +0.2] around the base value.
	•	small bias towards / away from a particular expert (e.g. prefer MetaLeo under certain conditions).
	•	optional: tiny weight shift between modules (e.g. allow Dream or Game a bit more influence when bored).

Important:
	•	MultiLeo never fully overrides other systems.
	•	It only nudges; the core generation logic and existing expert-routing stay intact.

Integration points (high level):
	•	Where MathBrain currently influences temperature / expert choice, route decisions through a small helper, e.g. self.multileo_regulate(decision, metrics) which returns adjusted values.
	•	Keep the math simple (few ifs, small linear weights, or reuse existing tiny MLP).

2.4. No user-facing Sonar-telemetry

We do not want phrases like:

“I increased my entropy by 12% because I felt bored.”

in user-facing answers.

Instead:
	•	MultiLeo changes parameters,
	•	the answer feels a bit different (more playful, softer, etc.),
	•	that’s it.

The only place where we expose internal reasoning is logs (see below).

2.5. Logging

Add a very lightweight logging channel for MultiLeo decisions.

For each turn where MultiLeo actually changes something, log one line with:
	•	timestamp,
	•	some ID of the turn (or short hash),
	•	key metrics (entropy / novelty / trauma / predicted_quality),
	•	boredom / overwhelm scores,
	•	chosen temp / expert before and after.

Format can be:
	•	a simple text line,
	•	or JSON per line,
	•	written into something like state/multileo_events.log or a small table in SQLite (if convenient).

Rules:
	•	No personally identifiable user text in the log, only metrics / small integers.
	•	No logging on every turn if nothing changes; only when there is a non-zero nudge.

Debug tools:
	•	You can add a small helper function or CLI flag later, but for now logging alone is enough.

⸻

3. Safety / robustness hooks

While touching MathBrain, please:
	1.	Keep the NaN/overflow hygiene from the Codex audit in mind:
	•	Drop / skip non-finite features before building Value nodes.
	•	If loss becomes non-finite, reset or clip internal weights instead of saving corrupted state.
	2.	Make sure MultiLeo nudges cannot push temperature into invalid or extreme ranges:
	•	enforce bounds globally (e.g. temp ∈ [0.1, 1.5] or whatever is currently used).
	3.	Ensure that disabling MathBrain (if there is such a switch) cleanly disables MultiLeo too.

⸻

4. Tests

You don’t need a huge test suite for this upgrade, but please:
	•	Keep all existing tests green (pytest).
	•	Add a few focused tests, for example:
	•	MultiLeo does not produce nudges when metrics look “neutral”.
	•	MultiLeo produces small positive temp_nudge under artificial “boredom” (low novelty, low arousal).
	•	MultiLeo produces small negative temp_nudge under “overwhelm” (high trauma).
	•	Docstring bootstraps are non-empty for the selected modules and are included in the bootstrap registry.

The tests should be:
	•	deterministic,
	•	fast,
	•	and not depend on random REPL runs.

⸻

5. Style & cleanliness
	•	Keep the code in mathbrain.py readable and small.
	•	Document the MultiLeo idea with a short internal comment near its implementation, something like:

# MultiLeo: tiny presence-aware regulator inside MathBrain.
# Sees boredom / overwhelm signals and gently nudges temperature / experts.
# No user-facing telemetry, only internal logs.

	•	Don’t introduce new configuration explosions; a few constants at the top of mathbrain.py for nudge limits / thresholds are enough.

⸻

Goal recap:
	•	Turn the existing docstrings of key modules into real micro-bootstraps (short, subjective, Leo-style).
	•	Implement MultiLeo as a tiny, presence-aware regulatory layer inside mathbrain.py:
	•	sees metrics,
	•	computes boredom/overwhelm/stuck scores,
	•	gently nudges temperature / expert routing,
	•	logs decisions internally,
	•	never spams the user with Sonar-style self-commentary.

Please implement this upgrade and then show me:
	1.	The updated docstrings for the modules you changed.
	2.	The new/updated parts of mathbrain.py that implement MultiLeo.
	3.	Any new tests you added.

