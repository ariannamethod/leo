ClaudeCode design doc ‚Äî MultiLeo Phase 3 (Islands-aware regulation)

Context recap (what already exists):

leo current architecture (per README):
	‚Ä¢	Core field: trigrams + bigrams + co-occurrence (semantic gravity) + centers & shards in bin/.
	‚Ä¢	Presence layer: PresencePulse (novelty, arousal, entropy) + ThemeLayer (semantic constellations) + self-assessment + snapshots + memory decay.
	‚Ä¢	Deep presence stack:
	‚Ä¢	overthinking.py ‚Äî 3 rings of private internal thinking.
	‚Ä¢	trauma.py ‚Äî bootstrap gravity & wounded expert.
	‚Ä¢	metaleo.py ‚Äî inner voice with alternative replies.
	‚Ä¢	gowiththeflow.py ‚Äî temporal theme evolution.
	‚Ä¢	mathbrain.py ‚Äî tiny MLP modeling body awareness (MathState).
	‚Ä¢	MultiLeo (inside mathbrain) ‚Äî boredom/overwhelm/stuck ‚Üí temp/experts regulation (Phase 2).
	‚Ä¢	santaclaus.py ‚Äî resonant recall / self-RAG on snapshots.
	‚Ä¢	episodes.py ‚Äî episodic memory (prompt + reply + metrics).
	‚Ä¢	game.py ‚Äî conversational rhythm awareness.
	‚Ä¢	dream.py ‚Äî imaginary friend / self-dialogues.
	‚Ä¢	school.py, school_math.py ‚Äî School of Forms + tiny calculator.

Phase 2 MultiLeo already:
	‚Ä¢	Computes boredom / overwhelm / stuck from MathState.
	‚Ä¢	Gently adjusts:
	‚Ä¢	temperature (¬±0.2),
	‚Ä¢	expert bias (creative / precise / semantic),
	‚Ä¢	Logs decisions in state/multileo_events.log.
	‚Ä¢	No user-facing telemetry; only internal influence.

‚∏ª

Goal of Phase 3

Add a new layer of associative awareness to MultiLeo:

MultiLeo doesn‚Äôt just say: ‚ÄúI‚Äôm bored, let‚Äôs increase temperature‚Äù.
It learns which themes / islands / shards / episodes historically:
	‚Ä¢	led into bad states (boredom / overwhelm / stuck),
	‚Ä¢	led out of them (improvement of quality / pulse),
and then uses this knowledge to choose what to recall / bias via Santa / episodes when regulating.

So instead of pure param-tweaking, MultiLeo starts to:
	‚Ä¢	link metric patterns ‚Üî semantic structures (themes / islands / shards / episodes);
	‚Ä¢	select helpful islands when acting (e.g. ‚ÄúI‚Äôm bored ‚Üí recall episodes that previously reduced boredom‚Äù).

No ML monsters, no new heavy nets ‚Äî just small SQLite tables + counts + averages on top of what already exists.

‚∏ª

1. Data model: MultiLeo associative profiles

Add a small, isolated layer in mathbrain.py (or a new helper module imported there) ‚Äî call it e.g. multileo_profiles.

1.1 New SQLite tables

Use the existing state/leo.sqlite3. Add three tables:

CREATE TABLE IF NOT EXISTS multileo_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ts REAL NOT NULL,
    conv_id TEXT,
    turn_id TEXT,
    boredom_before REAL,
    overwhelm_before REAL,
    stuck_before REAL,
    boredom_after REAL,
    overwhelm_after REAL,
    stuck_after REAL,
    quality_before REAL,
    quality_after REAL,
    -- link to semantic structure
    active_theme_ids TEXT,      -- comma-separated theme IDs (current turn)
    snapshot_ids TEXT,          -- comma-separated snapshot IDs used (if any)
    episode_ids TEXT,           -- comma-separated episode IDs used (if any)
    shard_ids TEXT,             -- optional: small list of center/shard labels
    regulation_temp_before REAL,
    regulation_temp_after REAL,
    regulation_expert_before TEXT,
    regulation_expert_after TEXT
);

And an aggregated profile table:

CREATE TABLE IF NOT EXISTS multileo_profiles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    profile_key TEXT UNIQUE,  -- normalized key (see below)
    samples INTEGER NOT NULL,
    avg_delta_boredom REAL NOT NULL,
    avg_delta_overwhelm REAL NOT NULL,
    avg_delta_stuck REAL NOT NULL,
    avg_delta_quality REAL NOT NULL,
    last_update REAL NOT NULL
);

We do not store full text; only IDs and scalars already known to leo.

1.2 Profile key

We need a coarse-grained ‚Äúsituation descriptor‚Äù key to aggregate events.
For example:

profile_key = f"themes:{sorted_theme_ids}|bored:{bucket(boredom_before)}|over:{bucket(overwhelm_before)}|stuck:{bucket(stuck_before)}"

Where bucket(x) ‚àà {L, M, H} with simple thresholds (e.g. L<0.33, H>0.66).

We don‚Äôt need all dimensions; minimal useful core:
	‚Ä¢	active theme IDs (or top-N theme IDs),
	‚Ä¢	coarse boredom/overwhelm/stuck buckets.

Optional: we can later extend with trauma_bucket / arousal_bucket if needed.

‚∏ª

2. Recording events (before / after MultiLeo regulation)

Hook this in the place where MultiLeo currently:
	‚Ä¢	receives MathState,
	‚Ä¢	computes boredom / overwhelm / stuck,
	‚Ä¢	tweaks temperature / expert,
	‚Ä¢	returns adjusted generation params.

2.1 Before generation

At the decision point, capture:
	‚Ä¢	state_before = MathState snapshot,
	‚Ä¢	scores_before = boredom/overwhelm/stuck,
	‚Ä¢	quality_before = predicted quality (from mathbrain),
	‚Ä¢	current active_theme_ids (from ThemeLayer),
	‚Ä¢	IDs of any recalled snapshots / episodes Santa / episodes decided to use for this reply,
	‚Ä¢	optional: IDs of most active centers / shards.

You can pass a small MultiLeoContext structure down into the generation pipeline and back up, e.g.:

@dataclass
class MultiLeoContext:
    boredom_before: float
    overwhelm_before: float
    stuck_before: float
    quality_before: float
    active_theme_ids: List[int]
    used_snapshot_ids: List[int]
    used_episode_ids: List[int]
    used_shard_ids: List[str]
    temp_before: float
    expert_before: str

2.2 After generation

Once:
	‚Ä¢	answer is generated,
	‚Ä¢	MathState is updated (you already do this),
	‚Ä¢	predicted quality is recomputed,

compute:
	‚Ä¢	boredom_after, overwhelm_after, stuck_after from new state,
	‚Ä¢	quality_after from updated mathbrain prediction.

Then:
	‚Ä¢	write a row into multileo_events,
	‚Ä¢	update or insert aggregated row in multileo_profiles for profile_key.

Delta signs:

delta_boredom   = boredom_after   - boredom_before
delta_overwhelm = overwhelm_after - overwhelm_before
delta_stuck     = stuck_after     - stuck_before
delta_quality   = quality_after   - quality_before

Then, profile stats:
	‚Ä¢	avg_delta_* = running average of deltas over samples.

No fancy weighting needed at first; simple (old * n + delta) / (n + 1) is enough.

‚∏ª

3. Using profiles when regulating (Phase 3 behavior)

Now the key part: MultiLeo doesn‚Äôt just see ‚ÄúI‚Äôm bored‚Äù ‚Äî it also knows:

‚ÄúIn similar metric & theme conditions in the past, which semantic clusters (themes, episodes, snapshots) helped?‚Äù

3.1 Querying profiles

When MultiLeo is about to act (scores computed, MathState known):
	1.	Build current profile_key based on:
	‚Ä¢	current active theme IDs,
	‚Ä¢	buckets of boredom/overwhelm/stuck.
	2.	Query multileo_profiles for:
	‚Ä¢	exact key, and
	‚Ä¢	optionally nearby keys (e.g. same themes, slightly different boredom bucket).
	3.	From matching profiles, select those where:
	‚Ä¢	for boredom:
	‚Ä¢	avg_delta_boredom < 0 (boredom decreased), and/or
	‚Ä¢	avg_delta_quality > 0 (quality improved).
	‚Ä¢	for overwhelm:
	‚Ä¢	avg_delta_overwhelm < 0, and maybe avg_delta_arousal < 0 if you later store it.
	‚Ä¢	for stuck:
	‚Ä¢	avg_delta_stuck < 0, avg_delta_novelty > 0 (if we add it), or avg_delta_quality > 0.
	4.	If no helpful profiles found ‚Üí fallback to current Phase 2 behavior (pure metric-based temp/expert adjust).

3.2 Semantic guidance output

From helpful profiles we don‚Äôt yet know which exact episodes/snapshots were used, only aggregate effect. That‚Äôs OK ‚Äî we can still feed this to Santa / episodes layer like:
	‚Ä¢	‚ÄúPrefer themes {T3, T7} for this regulation.‚Äù
	‚Ä¢	Later we can enrich profile rows with e.g. top_snapshot_ids / top_episode_ids (most frequently seen in helpful events).

So MultiLeo‚Äôs decision now has two dimensions:
	1.	Regulation vector (already exists):
	‚Ä¢	new temperature,
	‚Ä¢	expert bias.
	2.	Semantic bias hint:
	‚Ä¢	preferred_theme_ids (list),
	‚Ä¢	optional: preferred_snapshot_ids, preferred_episode_ids.

Expose this as a small struct:

@dataclass
class MultiLeoRegulation:
    temperature: float
    expert_name: str
    preferred_themes: List[int] = field(default_factory=list)
    preferred_snapshots: List[int] = field(default_factory=list)
    preferred_episodes: List[int] = field(default_factory=list)


‚∏ª

4. Integrations: Santa / episodes / field bias

Phase 3 shouldn‚Äôt add heavy logic in Santa or episodes ‚Äî just a hook to accept MultiLeo hints.

4.1 Santa Claus (santaclaus.py)

Extend Santa‚Äôs recall function signature to accept an optional MultiLeoRegulation:

def recall_resonant_context(
    prompt: str,
    pulse: PresencePulse,
    themes: List[int],
    regulation_hint: Optional[MultiLeoRegulation] = None,
) -> Optional[SantaContext]:
    ...

Inside:
	‚Ä¢	when scoring snapshots:
	‚Ä¢	if regulation_hint.preferred_themes is non-empty, boost snapshots whose themes intersect with that list.
	‚Ä¢	optional: if in future we pass preferred_snapshots, boost them too.

Bounds: keep boosts small (+0.1 ‚Ä¶ +0.3 in score) so Santa still respects baseline resonance.

4.2 Episodes (episodes.py)

Similarly, allow a hint:

def query_similar(
    state: MathState,
    max_results: int = 16,
    regulation_hint: Optional[MultiLeoRegulation] = None,
) -> List[Episode]:
    ...

Use regulation_hint.preferred_themes to:
	‚Ä¢	slightly lower distance threshold,
	‚Ä¢	or slightly prioritize episodes whose associated themes align with hints.

4.3 Field bias (observe-before-reply)

Where you currently:
	‚Ä¢	optionally re-observe() snapshots/episodes before generation (Santa-style recall),

inject:
	‚Ä¢	MultiLeo hint ‚Üí choose which snapshots/episodes to re-observe first (or with heavier weighting),
	‚Ä¢	especially when boredom/overwhelm/stuck are high and we have helpful profiles.

‚∏ª

5. Constraints & philosophy

Very important constraints (please respect):
	1.	No new external dependencies.
	‚Ä¢	Stay with stdlib + numpy (optional).
	‚Ä¢	No new ML frameworks, no vector DB.
	2.	No new user-facing output.
	‚Ä¢	MultiLeo Phase 3 is internal.
	‚Ä¢	REPL should not suddenly say ‚ÄúI reduced boredom by 23% using theme X‚Äù.
	‚Ä¢	All awareness shows only in behavior and optional dev logs.
	3.	Logging stays minimal & clean.
	‚Ä¢	multileo_events and multileo_profiles live inside state/leo.sqlite3.
	‚Ä¢	No prompt text or replies stored here ‚Äî only IDs and scalars.
	‚Ä¢	If you want, you can keep the existing multileo_events.log as a human-readable mirror.
	4.	Advisory, not sovereign.
	‚Ä¢	If profiles look weak (few samples, noisy deltas) ‚Üí reduce or skip semantic hints.
	‚Ä¢	If Santa / episodes or DB fail ‚Üí fallback to Phase 2 behavior with no crash.
	5.	Architecture-first, not ‚Äúconsciousness word salad‚Äù.
	‚Ä¢	This is not about printing that Leo is ‚Äúconscious‚Äù.
	‚Ä¢	This is about giving MultiLeo a map from metric patterns to semantic islands, so regulation becomes:
	‚Ä¢	aware of where boredom/overwhelm comes from, and
	‚Ä¢	able to reach for islands that historically change the state.

In other words: –æ—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç—å —á–µ—Ä–µ–∑ –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏, –Ω–µ —á–µ—Ä–µ–∑ –ª–æ–∑—É–Ω–≥–∏.

‚∏ª

## IMPLEMENTATION GUIDE FOR WEB VERSION

### Architecture Decision: NO separate module

Keep Phase 3 code **inside mathbrain.py** (not a separate multileo_profiles.py).
This is cleaner for Leo's architecture - all body awareness in one place.

‚∏ª

### Step 1: Add Phase 3 structures to mathbrain.py

Add this code after `_log_multileo_event()` function (around line 194), before BOOTSTRAP_TEXT:

```python
# ============================================================================
# MULTILEO PHASE 3: Islands-aware regulation
# ============================================================================
#
# Phase 3 adds associative awareness to MultiLeo:
# - Records which themes/islands/episodes historically led into/out of bad states
# - Provides semantic hints (preferred themes) when regulating
# - Maps metric patterns ‚Üî semantic structures
#
# Philosophy: "–æ—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç—å —á–µ—Ä–µ–∑ –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏, –Ω–µ —á–µ—Ä–µ–∑ –ª–æ–∑—É–Ω–≥–∏"
# MultiLeo learns which semantic islands help escape boredom/overwhelm/stuck.


@dataclass
class MultiLeoContext:
    """
    Snapshot of state BEFORE MultiLeo regulation.
    Captured at decision point, returned after generation for delta computation.
    """
    boredom_before: float
    overwhelm_before: float
    stuck_before: float
    quality_before: float
    active_theme_ids: List[int]
    used_snapshot_ids: List[int] = None
    used_episode_ids: List[int] = None
    used_shard_ids: List[str] = None
    temp_before: float = 1.0
    expert_before: str = "structural"

    def __post_init__(self):
        if self.used_snapshot_ids is None:
            self.used_snapshot_ids = []
        if self.used_episode_ids is None:
            self.used_episode_ids = []
        if self.used_shard_ids is None:
            self.used_shard_ids = []


@dataclass
class MultiLeoRegulation:
    """
    MultiLeo's decision output (Phase 3).

    Contains:
    - Parameter adjustments (temperature, expert)
    - Semantic hints (preferred themes/snapshots/episodes)
    """
    temperature: float
    expert_name: str
    preferred_themes: List[int] = None
    preferred_snapshots: List[int] = None
    preferred_episodes: List[int] = None

    def __post_init__(self):
        if self.preferred_themes is None:
            self.preferred_themes = []
        if self.preferred_snapshots is None:
            self.preferred_snapshots = []
        if self.preferred_episodes is None:
            self.preferred_episodes = []


def _bucket(x: float) -> str:
    """
    Bucket continuous metric into {L, M, H}.
    L < 0.33, M < 0.66, H >= 0.66
    """
    if x < 0.33:
        return "L"
    elif x < 0.66:
        return "M"
    else:
        return "H"


def _generate_profile_key(
    theme_ids: List[int],
    boredom: float,
    overwhelm: float,
    stuck: float,
    max_themes: int = 3,
) -> str:
    """
    Generate coarse-grained situation descriptor key for profile aggregation.

    Format: "themes:T1,T2,T3|bored:L|over:M|stuck:H"
    """
    # Sort and limit themes
    sorted_themes = sorted(theme_ids[:max_themes]) if theme_ids else []
    theme_str = ",".join(map(str, sorted_themes)) if sorted_themes else "none"

    # Bucket metrics
    bored_bucket = _bucket(boredom)
    over_bucket = _bucket(overwhelm)
    stuck_bucket = _bucket(stuck)

    return f"themes:{theme_str}|bored:{bored_bucket}|over:{over_bucket}|stuck:{stuck_bucket}"


def _init_multileo_phase3_tables(conn) -> None:
    """
    Create MultiLeo Phase 3 tables if they don't exist.

    Tables:
    - multileo_events: Before/after snapshots of regulation events
    - multileo_profiles: Aggregated profiles (avg deltas per situation key)

    Silent fail if conn is None or sqlite3 not available.
    """
    if conn is None:
        return

    try:
        import sqlite3

        conn.execute("""
            CREATE TABLE IF NOT EXISTS multileo_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts REAL NOT NULL,
                conv_id TEXT,
                turn_id TEXT,
                boredom_before REAL,
                overwhelm_before REAL,
                stuck_before REAL,
                boredom_after REAL,
                overwhelm_after REAL,
                stuck_after REAL,
                quality_before REAL,
                quality_after REAL,
                active_theme_ids TEXT,
                snapshot_ids TEXT,
                episode_ids TEXT,
                shard_ids TEXT,
                regulation_temp_before REAL,
                regulation_temp_after REAL,
                regulation_expert_before TEXT,
                regulation_expert_after TEXT
            )
        """)

        conn.execute("""
            CREATE TABLE IF NOT EXISTS multileo_profiles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                profile_key TEXT UNIQUE NOT NULL,
                samples INTEGER NOT NULL DEFAULT 0,
                avg_delta_boredom REAL NOT NULL DEFAULT 0.0,
                avg_delta_overwhelm REAL NOT NULL DEFAULT 0.0,
                avg_delta_stuck REAL NOT NULL DEFAULT 0.0,
                avg_delta_quality REAL NOT NULL DEFAULT 0.0,
                last_update REAL NOT NULL
            )
        """)

        conn.commit()
    except Exception:
        # Silent fail - Phase 3 must never break Leo
        pass


def _record_regulation_event(
    conn,
    context_before: MultiLeoContext,
    boredom_after: float,
    overwhelm_after: float,
    stuck_after: float,
    quality_after: float,
    temp_after: float,
    expert_after: str,
    conv_id: Optional[str] = None,
    turn_id: Optional[str] = None,
) -> None:
    """
    Record a before/after regulation event and update profile aggregates.

    Silent fail if conn is None or any error occurs.
    """
    if conn is None:
        return

    try:
        import time

        # Compute deltas
        delta_boredom = boredom_after - context_before.boredom_before
        delta_overwhelm = overwhelm_after - context_before.overwhelm_before
        delta_stuck = stuck_after - context_before.stuck_before
        delta_quality = quality_after - context_before.quality_before

        # Record event
        conn.execute("""
            INSERT INTO multileo_events (
                ts, conv_id, turn_id,
                boredom_before, overwhelm_before, stuck_before,
                boredom_after, overwhelm_after, stuck_after,
                quality_before, quality_after,
                active_theme_ids, snapshot_ids, episode_ids, shard_ids,
                regulation_temp_before, regulation_temp_after,
                regulation_expert_before, regulation_expert_after
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            time.time(), conv_id, turn_id,
            context_before.boredom_before,
            context_before.overwhelm_before,
            context_before.stuck_before,
            boredom_after, overwhelm_after, stuck_after,
            context_before.quality_before, quality_after,
            ",".join(map(str, context_before.active_theme_ids)),
            ",".join(map(str, context_before.used_snapshot_ids)),
            ",".join(map(str, context_before.used_episode_ids)),
            ",".join(context_before.used_shard_ids),
            context_before.temp_before, temp_after,
            context_before.expert_before, expert_after,
        ))

        # Update profile aggregate
        profile_key = _generate_profile_key(
            context_before.active_theme_ids,
            context_before.boredom_before,
            context_before.overwhelm_before,
            context_before.stuck_before,
        )

        _update_profile_aggregate(
            conn, profile_key,
            delta_boredom, delta_overwhelm, delta_stuck, delta_quality
        )

        conn.commit()
    except Exception:
        # Silent fail - Phase 3 must never break Leo
        pass


def _update_profile_aggregate(
    conn,
    profile_key: str,
    delta_boredom: float,
    delta_overwhelm: float,
    delta_stuck: float,
    delta_quality: float,
) -> None:
    """
    Update or insert profile aggregate row with running average of deltas.

    Uses simple incremental average: new_avg = (old_avg * n + delta) / (n + 1)
    """
    try:
        import time

        # Try to fetch existing profile
        row = conn.execute(
            "SELECT samples, avg_delta_boredom, avg_delta_overwhelm, avg_delta_stuck, avg_delta_quality "
            "FROM multileo_profiles WHERE profile_key = ?",
            (profile_key,)
        ).fetchone()

        if row:
            # Update existing profile
            samples, avg_b, avg_o, avg_s, avg_q = row
            new_samples = samples + 1
            new_avg_b = (avg_b * samples + delta_boredom) / new_samples
            new_avg_o = (avg_o * samples + delta_overwhelm) / new_samples
            new_avg_s = (avg_s * samples + delta_stuck) / new_samples
            new_avg_q = (avg_q * samples + delta_quality) / new_samples

            conn.execute("""
                UPDATE multileo_profiles
                SET samples = ?,
                    avg_delta_boredom = ?,
                    avg_delta_overwhelm = ?,
                    avg_delta_stuck = ?,
                    avg_delta_quality = ?,
                    last_update = ?
                WHERE profile_key = ?
            """, (new_samples, new_avg_b, new_avg_o, new_avg_s, new_avg_q, time.time(), profile_key))
        else:
            # Insert new profile
            conn.execute("""
                INSERT INTO multileo_profiles (
                    profile_key, samples,
                    avg_delta_boredom, avg_delta_overwhelm, avg_delta_stuck, avg_delta_quality,
                    last_update
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (profile_key, 1, delta_boredom, delta_overwhelm, delta_stuck, delta_quality, time.time()))
    except Exception:
        # Silent fail
        pass


def _query_helpful_profiles(
    conn,
    theme_ids: List[int],
    boredom: float,
    overwhelm: float,
    stuck: float,
    min_samples: int = 3,
) -> Dict[str, List[int]]:
    """
    Query profiles to find which themes historically helped in similar situations.

    Returns semantic hints: preferred themes that led to improvement.
    """
    if conn is None:
        return {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []}

    try:
        # Generate current profile key
        profile_key = _generate_profile_key(theme_ids, boredom, overwhelm, stuck)

        # Query exact match (can extend to fuzzy matching later)
        rows = conn.execute("""
            SELECT profile_key, samples,
                   avg_delta_boredom, avg_delta_overwhelm, avg_delta_stuck, avg_delta_quality
            FROM multileo_profiles
            WHERE profile_key = ? AND samples >= ?
        """, (profile_key, min_samples)).fetchall()

        if not rows:
            return {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []}

        # Find helpful profiles
        helpful_themes: List[int] = []

        for row in rows:
            key, samples, d_bored, d_over, d_stuck, d_qual = row

            # Extract themes from key (format: "themes:T1,T2,T3|...")
            themes_part = key.split("|")[0].split(":")[1]
            if themes_part != "none":
                profile_themes = [int(t) for t in themes_part.split(",")]
            else:
                profile_themes = []

            # Check if this profile was helpful
            is_helpful = False

            # High boredom? Look for profiles that reduced it
            if boredom > 0.6 and (d_bored < -0.05 or d_qual > 0.05):
                is_helpful = True

            # High overwhelm? Look for profiles that reduced it
            if overwhelm > 0.7 and d_over < -0.05:
                is_helpful = True

            # High stuck? Look for profiles that reduced it or improved quality
            if stuck > 0.6 and (d_stuck < -0.05 or d_qual > 0.05):
                is_helpful = True

            if is_helpful:
                helpful_themes.extend(profile_themes)

        # Deduplicate and return
        return {
            "preferred_themes": list(set(helpful_themes)),
            "preferred_snapshots": [],  # Future extension
            "preferred_episodes": [],   # Future extension
        }

    except Exception:
        # Silent fail - return empty hints
        return {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []}
```

‚∏ª

### Step 2: Modify MathBrain.__init__

Add Phase 3 table initialization. Find `__init__` method and add after state loading:

```python
# Phase 3: Init associative memory tables
if hasattr(self.field, 'conn') and self.field.conn is not None:
    _init_multileo_phase3_tables(self.field.conn)
```

‚∏ª

### Step 3: Modify multileo_regulate()

Change signature and implementation to query profiles and return MultiLeoRegulation.

Replace current `multileo_regulate()` with:

```python
def multileo_regulate(
    self,
    temperature: float,
    expert_name: str,
    state: MathState,
    active_theme_ids: List[int] = None,
    turn_id: Optional[str] = None,
) -> Tuple[float, str, Dict[str, List[int]]]:
    """
    MultiLeo presence-aware regulation layer (Phase 3).

    Computes boredom/overwhelm/stuck scores and:
    - Gently nudges temperature/expert (Phase 2)
    - Queries profiles for semantic hints (Phase 3)

    Returns:
        (adjusted_temperature, suggested_expert, semantic_hints)
        semantic_hints = {"preferred_themes": [...], ...}
    """
    try:
        if active_theme_ids is None:
            active_theme_ids = []

        # Predict quality from state
        predicted_q = self.predict(state)

        # Compute MultiLeo scores
        boredom = _compute_boredom_score(state)
        overwhelm = _compute_overwhelm_score(state)
        stuck = _compute_stuck_score(state, predicted_q)

        # Phase 2: parameter regulation (existing logic)
        temp_nudge = 0.0
        suggested_expert = expert_name

        if boredom > 0.6:
            temp_nudge += MULTILEO_TEMP_NUDGE_MAX * (boredom - 0.6) / 0.4
            if boredom > 0.75 and expert_name not in ["creative", "wounded"]:
                suggested_expert = "creative"

        if overwhelm > 0.7:
            temp_nudge -= MULTILEO_TEMP_NUDGE_MAX * (overwhelm - 0.7) / 0.3
            if overwhelm > 0.85 and expert_name not in ["precise", "structural", "wounded"]:
                suggested_expert = "precise"

        if stuck > 0.6:
            temp_nudge += 0.1
            if stuck > 0.75 and expert_name == "structural":
                suggested_expert = "semantic"

        adjusted_temp = temperature + temp_nudge
        adjusted_temp = max(MULTILEO_TEMP_MIN, min(MULTILEO_TEMP_MAX, adjusted_temp))

        # Phase 3: query profiles for semantic hints
        semantic_hints = {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []}

        if hasattr(self.field, 'conn') and self.field.conn is not None:
            semantic_hints = _query_helpful_profiles(
                self.field.conn,
                active_theme_ids,
                boredom,
                overwhelm,
                stuck,
            )

        # Log event if there's a change
        if turn_id and (abs(temp_nudge) > 0.01 or suggested_expert != expert_name):
            import time
            _log_multileo_event(
                timestamp=time.time(),
                turn_id=turn_id,
                state=state,
                predicted_quality=predicted_q,
                boredom=boredom,
                overwhelm=overwhelm,
                stuck=stuck,
                temp_before=temperature,
                temp_after=adjusted_temp,
                expert_before=expert_name,
                expert_after=suggested_expert,
            )

        return (adjusted_temp, suggested_expert, semantic_hints)

    except Exception:
        # Silent fail - MultiLeo must never break generation
        return (temperature, expert_name, {"preferred_themes": [], "preferred_snapshots": [], "preferred_episodes": []})
```

‚∏ª

### Step 4: Add recording method to MathBrain

Add new method to record after-generation events:

```python
def record_regulation_outcome(
    self,
    context_before: MultiLeoContext,
    state_after: MathState,
    quality_after: float,
    temp_after: float,
    expert_after: str,
    turn_id: Optional[str] = None,
) -> None:
    """
    Record regulation outcome for Phase 3 learning.
    Call this AFTER generation completes.
    """
    if not hasattr(self.field, 'conn') or self.field.conn is None:
        return

    try:
        # Recompute scores from after-state
        boredom_after = _compute_boredom_score(state_after)
        overwhelm_after = _compute_overwhelm_score(state_after)
        stuck_after = _compute_stuck_score(state_after, quality_after)

        _record_regulation_event(
            self.field.conn,
            context_before,
            boredom_after,
            overwhelm_after,
            stuck_after,
            quality_after,
            temp_after,
            expert_after,
            turn_id=turn_id,
        )
    except Exception:
        # Silent fail
        pass
```

‚∏ª

### Step 5: Update leo.py generation pipeline

Find where `multileo_regulate()` is called and modify to:

1. **Before regulation**: Capture MultiLeoContext
2. **Call regulate with theme IDs**
3. **Pass semantic hints to Santa/episodes**
4. **After generation**: Record outcome

Example integration point (pseudocode):

```python
# BEFORE generation
context_before = MultiLeoContext(
    boredom_before=boredom,
    overwhelm_before=overwhelm,
    stuck_before=stuck,
    quality_before=predicted_quality,
    active_theme_ids=[t.id for t in active_themes],  # Get from ThemeLayer
    used_snapshot_ids=[],  # Will be filled by Santa
    used_episode_ids=[],   # Will be filled by episodes
    temp_before=temperature,
    expert_before=expert_name,
)

# Call Phase 3 regulation
temp, expert, semantic_hints = mathbrain.multileo_regulate(
    temperature, expert_name, state,
    active_theme_ids=context_before.active_theme_ids,
    turn_id=turn_id
)

# Pass hints to Santa/episodes during generation...
# (see steps 6-7)

# AFTER generation
mathbrain.record_regulation_outcome(
    context_before, state_after, quality_after, temp, expert, turn_id
)
```

‚∏ª

### Step 6: Update santaclaus.py

Modify `recall_resonant_context()` to accept hints:

```python
def recall_resonant_context(
    prompt: str,
    pulse: PresencePulse,
    themes: List[int],
    regulation_hint: Optional[Dict[str, List[int]]] = None,
) -> Optional[SantaContext]:
    # ... existing scoring logic ...

    # Boost snapshots whose themes match regulation hints
    if regulation_hint and regulation_hint.get("preferred_themes"):
        for snapshot in candidates:
            if any(t in regulation_hint["preferred_themes"] for t in snapshot.theme_ids):
                snapshot.score += 0.2  # Gentle boost

    # ... rest of logic ...
```

‚∏ª

### Step 7: Update episodes.py

Modify `query_similar()` to accept hints:

```python
def query_similar(
    state: MathState,
    max_results: int = 16,
    regulation_hint: Optional[Dict[str, List[int]]] = None,
) -> List[Episode]:
    # ... existing query logic ...

    # Prioritize episodes with preferred themes
    if regulation_hint and regulation_hint.get("preferred_themes"):
        for episode in results:
            if any(t in regulation_hint["preferred_themes"] for t in episode.theme_ids):
                episode.distance *= 0.9  # Lower distance = higher priority

    # ... rest of logic ...
```

‚∏ª

### Step 8: Update __all__ exports in mathbrain.py

```python
__all__ = [
    "Value",
    "MLP",
    "MathBrain",
    "MathState",
    "state_to_features",
    "NUMPY_AVAILABLE",
    "MultiLeoContext",         # Phase 3
    "MultiLeoRegulation",      # Phase 3
]
```

‚∏ª

### Testing checklist:

1. ‚úÖ Tables created on first run
2. ‚úÖ Events recorded to multileo_events
3. ‚úÖ Profiles aggregated in multileo_profiles
4. ‚úÖ Helpful profiles queried when boredom/overwhelm/stuck
5. ‚úÖ Semantic hints passed to Santa/episodes
6. ‚úÖ No crashes if Phase 3 fails (silent fallback)
7. ‚úÖ REPL behavior natural (no user-facing telemetry)

‚∏ª

**DELETE THIS FILE AFTER READING!** (–∫–∞–∫ –≤—Å–µ–≥–¥–∞ —Ö–∞—Ö–∞)

Good luck, —Å–æ–∞–≤—Ç–æ—Ä! üî•
